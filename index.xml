<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeiiWang&#39;s Blog</title>
    <link>http://u2takey.github.io/</link>
    <description>Recent content on LeiiWang&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 31 Jul 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://u2takey.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>influxdb中文精简文档</title>
      <link>http://u2takey.github.io/blog/influxdb%E4%B8%AD%E6%96%87%E7%B2%BE%E7%AE%80%E6%96%87%E6%A1%A3/</link>
      <pubDate>Sun, 31 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://u2takey.github.io/blog/influxdb%E4%B8%AD%E6%96%87%E7%B2%BE%E7%AE%80%E6%96%87%E6%A1%A3/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;参考&lt;a href=&#34;https://docs.influxdata.com/influxdb/v0.13/&#34;&gt;https://docs.influxdata.com/influxdb/v0.13/&lt;/a&gt;, 当前版本0.13, 这是一个简化版的文档，摘录文档中我认为比较重要的概念内容,
influxdb目前更新很快，不同版本之间概念差异很大，阅读时请注意当前最新版本。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;!-- vscode-markdown-toc --&gt;

&lt;ul&gt;
&lt;li&gt;1. &lt;a href=&#34;#-0&#34;&gt;概要&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;1.1. &lt;a href=&#34;#-1&#34;&gt;简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.2. &lt;a href=&#34;#-2&#34;&gt;下载和安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.3. &lt;a href=&#34;#-3&#34;&gt;入门&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;1.3.1. &lt;a href=&#34;#-4&#34;&gt;创建数据库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.3.2. &lt;a href=&#34;#-5&#34;&gt;读写数据&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2. &lt;a href=&#34;#-6&#34;&gt;指南&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;2.1. &lt;a href=&#34;#-7&#34;&gt;写数据&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;2.1.1. &lt;a href=&#34;#HTTPAPI-8&#34;&gt;使用HTTP API创建数据库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.1.2. &lt;a href=&#34;#HTTPAPI-9&#34;&gt;使用HTTP API写入数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.1.3. &lt;a href=&#34;#-10&#34;&gt;写多个点数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.1.4. &lt;a href=&#34;#-11&#34;&gt;从文件中写入点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.1.5. &lt;a href=&#34;#SchemalessDesign-12&#34;&gt;Schemaless Design&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.1.6. &lt;a href=&#34;#REST...-13&#34;&gt;关于REST&amp;hellip;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.1.7. &lt;a href=&#34;#HTTP-14&#34;&gt;HTTP响应概要&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2.2. &lt;a href=&#34;#-15&#34;&gt;查询数据&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;2.2.1. &lt;a href=&#34;#HTTPAPI-16&#34;&gt;使用 HTTP API查询数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.2.2. &lt;a href=&#34;#-17&#34;&gt;多个查询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.2.3. &lt;a href=&#34;#-18&#34;&gt;查询数据的其他选项&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2.3. &lt;a href=&#34;#DownsamplingandDataRetention-19&#34;&gt;缩减采样和数据保留（Downsampling and Data Retention）&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;2.3.1. &lt;a href=&#34;#retentionpolicies-20&#34;&gt;保留策略retention policies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.3.2. &lt;a href=&#34;#-21&#34;&gt;连续查询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.3.3. &lt;a href=&#34;#RPsandCQs--22&#34;&gt;结合 RPs and CQs - 一个案例研究&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2.4. &lt;a href=&#34;#-23&#34;&gt;硬件指南&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3. &lt;a href=&#34;#-24&#34;&gt;概念&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /vscode-markdown-toc --&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;1-a-name-0-a-概要&#34;&gt;1. &lt;a name=&#39;-0&#39;&gt;&lt;/a&gt;概要&lt;/h2&gt;

&lt;h3 id=&#34;1-1-a-name-1-a-简介&#34;&gt;1.1. &lt;a name=&#39;-1&#39;&gt;&lt;/a&gt;简介&lt;/h3&gt;

&lt;p&gt;InfluxDB是一个时间序列数据库，支持高效的写入和查询。 InfluxDB被设计来存储开发监控，应用指标，物联网传感数据，实时分析等产生的大量的时间序列数据。&lt;/p&gt;

&lt;p&gt;为什么选择InfluxDB？
- 为高性能数据存储的时间序列数据而编写。使用TSM引擎支持高存取速度和数据压缩。
- go语言编写，无外部依赖。
- 简单高效的HTTP（S）的API。
- 支持Graphite，collectd和OpenTSDB插件。
- 高可用性设置（基于Relay）。
- 类SQL的查询语言，轻松查询汇总数据。
- tags支持建立索引，以便快速，高效的查询。
- 保留策略（Retention policies）有效地自动清理过期数据。
- 连续查询（Continuous queries）自动汇总数据以提高查询效率。
- 内置Web管理界面。&lt;/p&gt;

&lt;h3 id=&#34;1-2-a-name-2-a-下载和安装&#34;&gt;1.2. &lt;a name=&#39;-2&#39;&gt;&lt;/a&gt;下载和安装&lt;/h3&gt;

&lt;p&gt;略&lt;/p&gt;

&lt;h3 id=&#34;1-3-a-name-3-a-入门&#34;&gt;1.3. &lt;a name=&#39;-3&#39;&gt;&lt;/a&gt;入门&lt;/h3&gt;

&lt;p&gt;本节使用命令行界面 &lt;code&gt;influx&lt;/code&gt;（CLI）作为演示，它已经包含在InfluxDB安装包中了，是与数据库交互的轻量级，简单的方式。 CLI中默认情况通过InfluxDB HTTP API使用端口&lt;code&gt;8086&lt;/code&gt;
与InfluxDB通信。&lt;/p&gt;

&lt;h4 id=&#34;1-3-1-a-name-4-a-创建数据库&#34;&gt;1.3.1. &lt;a name=&#39;-4&#39;&gt;&lt;/a&gt;创建数据库&lt;/h4&gt;

&lt;p&gt;执行&lt;code&gt;influx&lt;/code&gt;命令启动CLI并自动连接到本地InfluxDB实例（假设你已经使用service influxdb start或者直接运行influxd启动了influxdbserver)。输出应该是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ influx
Connected to http://localhost:8086 version 0.13.x
InfluxDB shell 0.13.x
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注：InfluxDB HTTP API默认在端口8086运行。因此，influx会默认连接端口&lt;code&gt;8086&lt;/code&gt;和&lt;code&gt;localhost&lt;/code&gt;。如果您需要更改这些默认设置，运行influx &amp;ndash;help。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在你可以使用Influx查询语句了（a.k.a InfluxQL）。要退出InfluxQL shell，键入&lt;code&gt;exit&lt;/code&gt;并回车。&lt;/p&gt;

&lt;p&gt;新安装的InfluxDB有没有数据库（除了系统的&lt;code&gt;_internal&lt;/code&gt;），所以创建先一个。使用&lt;code&gt;CREATE DATABASE  &amp;lt;db-name&amp;gt;&lt;/code&gt; 语句创建数据库，其中&lt;DB-name&gt;是您想要创建的数据库
的名称。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; CREATE DATABASE mydb
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注：按下回车键后，出现一个新的提示符，这意味着该语句执行完成，没有任何错误显示。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; SHOW DATABASES
name: databases
---------------
name
_internal
mydb

&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：_internal数据库是InfluxDB自动创建并使用来存储内部运行指标的数据库。有兴趣可以看看它了解Influx内部是怎么运行的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不同于&lt;code&gt;SHOW DATABASES&lt;/code&gt;，大部分的InfluxQL语句必须针对特定的数据库执行。你可以每次查询的时候都指定数据库，CLI提供了一个方便的语句，&lt;code&gt;USE &amp;lt;db-name&amp;gt;&lt;/code&gt;，
它会自动为之后的所有请求设置使用的数据库。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; USE mydb
Using database mydb
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这之后的命令只会使用mydb数据库运行。&lt;/p&gt;

&lt;h4 id=&#34;1-3-2-a-name-5-a-读写数据&#34;&gt;1.3.2. &lt;a name=&#39;-5&#39;&gt;&lt;/a&gt;读写数据&lt;/h4&gt;

&lt;p&gt;现在，我们有数据库了，InfluxDB可以接受查询和写入请求了。&lt;/p&gt;

&lt;p&gt;首先，简介一下datastore。在InfluxDB数据由“时间序列”（time series）组织，它包含一个测量值，例如“cpu_load”或“temperature”。时间序列有0到多个点，
一个点对应于一个测量数据。点包括&lt;code&gt;time&lt;/code&gt;（时间戳），&lt;code&gt;measurement&lt;/code&gt;（如“cpu_load”），至少一个键值字段&lt;code&gt;field&lt;/code&gt;
（测量值本身，例如，“value= 0.64”，或“temperature= 21.2”），以及一个或者多个键值标签&lt;code&gt;tags&lt;/code&gt;,tags是value的元数据（例如，“host= SERVER01”，“region= EMEA”，
“DC =Frankfurt”）。&lt;/p&gt;

&lt;p&gt;从概念上讲，你可以认为&lt;code&gt;measurement&lt;/code&gt;是一个SQL表，其主索引始终是时间。&lt;code&gt;tags&lt;/code&gt;和&lt;code&gt;field&lt;/code&gt;都表中的列。&lt;code&gt;tags&lt;/code&gt;有索引，&lt;code&gt;field&lt;/code&gt;没有。
不同的是，使用InfluxDB，你可以存储上百万的测量值，而不必提前定义schemas，并且null values 没有被存储。&lt;/p&gt;

&lt;p&gt;Points 被使用&lt;code&gt;Line Protocol&lt;/code&gt;写入InfluxDB，遵循以下格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;measurement&amp;gt;[,&amp;lt;tag-key&amp;gt;=&amp;lt;tag-value&amp;gt;...] &amp;lt;field-key&amp;gt;=&amp;lt;field-value&amp;gt;[,&amp;lt;field2-key&amp;gt;=&amp;lt;field2-value&amp;gt;...] [unix-nano-timestamp]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是可以写入InfluxDB的有效例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cpu,host=serverA,region=us_west value=0.64
payment,device=mobile,product=Notepad,method=credit billed=33,licenses=3i 1434067467100293230
stock,symbol=AAPL bid=127.46,ask=127.48
temperature,machine=unit42,type=assembly external=25,internal=37 1434067467000000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;INSERT&lt;/code&gt;命令插入一个时间序列点数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; INSERT cpu,host=serverA,region=us_west value=0.64
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个名称为name,tag 为host，值为value:0.64的数据被插入Db中了，现在可以查询我们刚刚插入的数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; SELECT host, region, value FROM cpu
name: cpu
---------
time		    	                     host     	region   value
2015-10-21T19:28:07.580664347Z  serverA	  us_west	 0.64

&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注：我们写数据的时候并没有提供一个timestamp。当没有提供timestamp的时候，InfluxDB会自动分配本地当前时间戳。这意味着和你的本地时间戳可能会有所不同。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;存储另一种数据，这个数据有两个fields&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; INSERT temperature,machine=unit42,type=assembly external=25,internal=37
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用*运算符查询所有数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; SELECT * FROM temperature
name: temperature
-----------------
time		                        	 external	  internal	machine	type
2015-10-21T19:28:08.385013942Z  25	        	37     		unit42  assembly

&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;InfluxQL还有有许多功能和关键字，这里没有覆盖，包括GO风格正则表达式的支持。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; SELECT * FROM /.*/限制1
- 
&amp;gt; SELECT * FROM cpu_load_short
- 
&amp;gt; SELECT * FROM cpu_load_short WHERE值&amp;gt; 0.9
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-a-name-6-a-指南&#34;&gt;2. &lt;a name=&#39;-6&#39;&gt;&lt;/a&gt;指南&lt;/h2&gt;

&lt;h3 id=&#34;2-1-a-name-7-a-写数据&#34;&gt;2.1. &lt;a name=&#39;-7&#39;&gt;&lt;/a&gt;写数据&lt;/h3&gt;

&lt;p&gt;可以使用包括命令行界面，客户端库和插件等多种方式向InfluxDB 写入数据。在这里，我们将向你展示如何使用数据库内置的HTTP API来创建数据库和写入数据。&lt;/p&gt;

&lt;h4 id=&#34;2-1-1-a-name-httpapi-8-a-使用http-api创建数据库&#34;&gt;2.1.1. &lt;a name=&#39;HTTPAPI-8&#39;&gt;&lt;/a&gt;使用HTTP API创建数据库&lt;/h4&gt;

&lt;p&gt;发送&lt;code&gt;POST&lt;/code&gt;请求到&lt;code&gt;/query&lt;/code&gt;，并设置URL参数&lt;code&gt;q&lt;/code&gt;为&lt;code&gt;CREATE DATABASE&lt;/code&gt;创建数据库&lt;code&gt;&amp;lt;new_database_name&amp;gt;&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -i -XPOST http://localhost:8086/query --data-urlencode &amp;quot;q=CREATE DATABASE mydb&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-1-2-a-name-httpapi-9-a-使用http-api写入数据&#34;&gt;2.1.2. &lt;a name=&#39;HTTPAPI-9&#39;&gt;&lt;/a&gt;使用HTTP API写入数据&lt;/h4&gt;

&lt;p&gt;HTTP API是将数据放入InfluxDB的主要手段。发送&lt;code&gt;POST&lt;/code&gt;请求到&lt;code&gt;/write&lt;/code&gt;。下面的例子写一个单点mydb数据库。数据为 measurement cpu_load_short，
 tag keys: host, region; tag values : server01, us-west, field key value: value -&amp;gt; 0.64, timestamp : 1434055562000000000&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -i -XPOST &#39;http://localhost:8086/write?db=mydb&#39; --data-binary &#39;cpu_load_short,host=server01,region=us-west value=0.64 1434055562000000000&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写点数据必须指定db参数。这个POST请求的BODY - 我们称之为线路协议- 包含您要保存的时间序列数据。它们由一个测量，标记，字段和时间戳
(measurement, tags, fields, and a timestamp) 组成。 InfluxDB需要一个测量名称(measurement name.)。严格地说，标签是可选的，常使用来区分数据源，并使进行查询既简单又高效。
标签键和标签值都是字符串。fields是必需的，始终是字符串，在默认情况下，字段值是floats。时间戳是可选的。如果不指定时间戳InfluxDB使用服务器的本地Unix纪元纳秒时间戳。
InfluxDB相关的时间都是UTC。&lt;/p&gt;

&lt;h4 id=&#34;2-1-3-a-name-10-a-写多个点数据&#34;&gt;2.1.3. &lt;a name=&#39;-10&#39;&gt;&lt;/a&gt;写多个点数据&lt;/h4&gt;

&lt;p&gt;通过换行符分隔多个序列的多个点，这种形式的Batching points可以提高性能。
下面的示例将写三个点到mydb数据库。
第一个点属于cpu_load_short， tag set host=server02， 使用 server’s local timestamp。
第二个点是属于cpu_load_short， tag set host=server02,region=us-west，使用指定的时间戳1422568543702900257。
第三个点具属于cpu_load_short， tag set direction=in,host=server01,region=us-west， 使用指定的时间戳1422568543702900257。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -i -XPOST &#39;http://localhost:8086/write?db=mydb&#39; --data-binary &#39;cpu_load_short,host=server02 value=0.67
cpu_load_short,host=server02,region=us-west value=0.55 1422568543702900257
cpu_load_short,direction=in,host=server01,region=us-west value=2.0 1422568543702900257&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-1-4-a-name-11-a-从文件中写入点&#34;&gt;2.1.4. &lt;a name=&#39;-11&#39;&gt;&lt;/a&gt;从文件中写入点&lt;/h4&gt;

&lt;p&gt;通过@filename向curl传入文件内容。该文件中的数据应该遵循InfluxDB的 line protocol syntax的语法。正确格式的文件（cpu_data.txt）的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cpu_load_short,host=server02 value=0.67
cpu_load_short,host=server02,region=us-west value=0.55 1422568543702900257
cpu_load_short,direction=in,host=server01,region=us-west value=2.0 1422568543702900257
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写cpu_data.txt到mydb数据库：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -i -XPOST &#39;http://localhost:8086/write?db=mydb&#39; --data-binary @cpu_data.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-1-5-a-name-schemalessdesign-12-a-schemaless-design&#34;&gt;2.1.5. &lt;a name=&#39;SchemalessDesign-12&#39;&gt;&lt;/a&gt;Schemaless Design&lt;/h4&gt;

&lt;p&gt;InfluxDB是一个Schemaless的数据库。您可以随时添加measurements, tags, 和 fields。但需要注意的是，如果你试图写入不同的数据类型到之前用过的数据库
（例如，写一个字符串到以前接受整型的字段，InfluxDB将拒绝这些数据。&lt;/p&gt;

&lt;h4 id=&#34;2-1-6-a-name-rest-13-a-关于rest&#34;&gt;2.1.6. &lt;a name=&#39;REST...-13&#39;&gt;&lt;/a&gt;关于REST&amp;hellip;&lt;/h4&gt;

&lt;p&gt;InfluxDB使用HTTP仅作为一种方便和广泛支持的数据传输协议。InfluxDB API并没有试图成为RESTful的。&lt;/p&gt;

&lt;h4 id=&#34;2-1-7-a-name-http-14-a-http响应概要&#34;&gt;2.1.7. &lt;a name=&#39;HTTP-14&#39;&gt;&lt;/a&gt;HTTP响应概要&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;2XX：如果&lt;code&gt;HTTP 204 No Content&lt;/code&gt;，请求成功了！如果它是HTTP 200 OK，InfluxDB理解了请求，但不能完成它。响应的BODEY会包含其他错误信息。&lt;/li&gt;
&lt;li&gt;4XX：InfluxDB无法理解的请求。&lt;/li&gt;
&lt;li&gt;5XX：系统超载有严重错误。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;错误响应示例：
- 写入float到以前接受bool的字段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -i -XPOST &#39;http://localhost:8086/write?db=hamlet&#39; --data-binary &#39;tobeornottobe booleanonly=true&#39;  

curl -i -XPOST &#39;http://localhost:8086/write?db=hamlet&#39; --data-binary &#39;tobeornottobe booleanonly=5&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 400 Bad Request
[...]
write failed: field type conflict: input field &amp;quot;booleanonly&amp;quot; on measurement &amp;quot;tobeornottobe&amp;quot; is type float64, already exists as type boolean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写入一个不存在的数据库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -i -XPOST &#39;http://localhost:8086/write?db=atlantis&#39; --data-binary &#39;liters value=10&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 404 Not Found
[...]
database not found: &amp;quot;atlantis&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-2-a-name-15-a-查询数据&#34;&gt;2.2. &lt;a name=&#39;-15&#39;&gt;&lt;/a&gt;查询数据&lt;/h3&gt;

&lt;h4 id=&#34;2-2-1-a-name-httpapi-16-a-使用-http-api查询数据&#34;&gt;2.2.1. &lt;a name=&#39;HTTPAPI-16&#39;&gt;&lt;/a&gt;使用 HTTP API查询数据&lt;/h4&gt;

&lt;p&gt;HTTP API是查询InfluxDB数据的主要方式（参见command line interface 和 client libraries 等替代方式来查询数据库）。&lt;/p&gt;

&lt;p&gt;要执行一个查询，发送&lt;code&gt;GET&lt;/code&gt;请求到&lt;code&gt;/query&lt;/code&gt;，设置URL参数db作为目标数据库，并设置URL参数q作为查询。下面的示例使用HTTP API来查询您在上一节写入的数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -GET &#39;http://localhost:8086/query?pretty=true&#39; --data-urlencode &amp;quot;db=mydb&amp;quot; --data-urlencode &amp;quot;q=SELECT value FROM cpu_load_short WHERE region=&#39;us-west&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;InfluxDB返回JSON。查询的结果显示在“results”数组中。如果发生错误，会有一个“error”字段来解释错误原因。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;results&amp;quot;: [
        {
            &amp;quot;series&amp;quot;: [
                {
                    &amp;quot;name&amp;quot;: &amp;quot;cpu_load_short&amp;quot;,
                    &amp;quot;columns&amp;quot;: [
                        &amp;quot;time&amp;quot;,
                        &amp;quot;value&amp;quot;
                    ],
                    &amp;quot;values&amp;quot;: [
                        [
                            &amp;quot;2015-01-29T21:55:43.702900257Z&amp;quot;,
                            0.55
                        ],
                        [
                            &amp;quot;2015-01-29T21:55:43.702900257Z&amp;quot;,
                            23422
                        ],
                        [
                            &amp;quot;2015-06-11T20:46:02Z&amp;quot;,
                            0.64
                        ]
                    ]
                }
            ]
        }
    ]
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 
&amp;gt; 注：追加pretty=true添加到URL能够漂亮的打印JSON输出。虽然这对调试很有用，不建议在生产中使用，因为它消耗了不必要的网络带宽。&lt;/p&gt;

&lt;h4 id=&#34;2-2-2-a-name-17-a-多个查询&#34;&gt;2.2.2. &lt;a name=&#39;-17&#39;&gt;&lt;/a&gt;多个查询&lt;/h4&gt;

&lt;p&gt;可以在一个API调用种发送多个查询。只需用分号分割每个查询语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -G &#39;http://localhost:8086/query?pretty=true&#39; --data-urlencode &amp;quot;db=mydb&amp;quot; --data-urlencode &amp;quot;q=SELECT value FROM\
 cpu_load_short WHERE region=&#39;us-west&#39;;SELECT count(value) FROM cpu_load_short WHERE region=&#39;us-west&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;results&amp;quot;: [
        {
            &amp;quot;series&amp;quot;: [
                {
                    &amp;quot;name&amp;quot;: &amp;quot;cpu_load_short&amp;quot;,
                    &amp;quot;columns&amp;quot;: [
                        &amp;quot;time&amp;quot;,
                        &amp;quot;value&amp;quot;
                    ],
                    &amp;quot;values&amp;quot;: [
                        [
                            &amp;quot;2015-01-29T21:55:43.702900257Z&amp;quot;,
                            0.55
                        ],
                        [
                            &amp;quot;2015-01-29T21:55:43.702900257Z&amp;quot;,
                            23422
                        ],
                        [
                            &amp;quot;2015-06-11T20:46:02Z&amp;quot;,
                            0.64
                        ]
                    ]
                }
            ]
        },
        {
            &amp;quot;series&amp;quot;: [
                {
                    &amp;quot;name&amp;quot;: &amp;quot;cpu_load_short&amp;quot;,
                    &amp;quot;columns&amp;quot;: [
                        &amp;quot;time&amp;quot;,
                        &amp;quot;count&amp;quot;
                    ],
                    &amp;quot;values&amp;quot;: [
                        [
                            &amp;quot;1970-01-01T00:00:00Z&amp;quot;,
                            3
                        ]
                    ]
                }
            ]
        }
    ]
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-2-3-a-name-18-a-查询数据的其他选项&#34;&gt;2.2.3. &lt;a name=&#39;-18&#39;&gt;&lt;/a&gt;查询数据的其他选项&lt;/h4&gt;

&lt;h5 id=&#34;时间戳格式timestamp-format&#34;&gt;时间戳格式Timestamp Format&lt;/h5&gt;

&lt;p&gt;在InfluxDB所有东西都被存为UTC格式。默认情况下，时间戳以RFC3339 UTC格式返回并提供纳秒级的精度，例如&lt;code&gt;2015-08-04T19：05：14.318570484Z&lt;/code&gt;。
如果你需要 Unix epoch format可以设置查询字符串参数&lt;code&gt;epoch = [H，M，S，MS，U，NS]&lt;/code&gt;。例如，获取秒单位时间戳：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -G &#39;http://localhost:8086/query&#39; --data-urlencode &amp;quot;db=mydb&amp;quot; --data-urlencode &amp;quot;epoch=s&amp;quot;\
 --data-urlencode &amp;quot;q=SELECT value FROM cpu_load_short WHERE region=&#39;us-west&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;鉴权authentication&#34;&gt;鉴权Authentication&lt;/h5&gt;

&lt;p&gt;Authentication in InfluxDB is disabled by default. See Authentication and Authorization for how to enable and set up authentication.&lt;/p&gt;

&lt;h5 id=&#34;最大行数maximum-row-limit&#34;&gt;最大行数Maximum Row Limit&lt;/h5&gt;

&lt;p&gt;最大行限制InfluxDB返回的结果的最大数量。默认设置为10,000，并且可以通过在配置文件的HTTP部分修改。
最大行限制仅适用于非分块查询。分块查询可以返回点的数量不受限制。&lt;/p&gt;

&lt;h5 id=&#34;分片chunking&#34;&gt;分片Chunking&lt;/h5&gt;

&lt;p&gt;通过设置&lt;code&gt;chunked=true&lt;/code&gt;来使用分块组块，用于返回streamed batches形式的结果，而不是单个resposne返回所有数据。
resposne将被按照series 或每10000个point分片。设置&lt;code&gt;chunk_size&lt;/code&gt;来改变最大块大小为不同的值
,例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -G &#39;http://localhost:8086/query&#39; --data-urlencode &amp;quot;db=deluge&amp;quot; --data-urlencode=&amp;quot;chunked=true&amp;quot; --data-urlencode &amp;quot;chunk_size=20000&amp;quot; \
--data-urlencode &amp;quot;q=SELECT * FROM liters&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-a-name-downsamplinganddataretention-19-a-缩减采样和数据保留-downsampling-and-data-retention&#34;&gt;2.3. &lt;a name=&#39;DownsamplingandDataRetention-19&#39;&gt;&lt;/a&gt;缩减采样和数据保留（Downsampling and Data Retention）&lt;/h3&gt;

&lt;p&gt;InfluxDB每秒能够处理成千上万的数据点。长时间运行将会消耗大量存储空间。一个自然的解决方案是：缩减采样数据;
只在有限的时间内保持高精度的原始数据，更长时间的数据则存储精度较低，汇总数据。
本节说明了如何结合两个InfluxDB功能 - 保留策略和连续查询（retention policies and continuous queries） - 来自动缩减采样和淘汰数据。&lt;/p&gt;

&lt;h4 id=&#34;2-3-1-a-name-retentionpolicies-20-a-保留策略retention-policies&#34;&gt;2.3.1. &lt;a name=&#39;retentionpolicies-20&#39;&gt;&lt;/a&gt;保留策略retention policies&lt;/h4&gt;

&lt;h5 id=&#34;定义&#34;&gt;定义&lt;/h5&gt;

&lt;p&gt;保留策略retention policy（RP）是InfluxDB的一种数据结构，用于描述InfluxDB保留数据多久（持续时间）和有多少数据副本存储在集群中（复制因子
replication factor）。一个数据库可以有多个RP，RP在每个数据库唯一。&lt;/p&gt;

&lt;h5 id=&#34;目的&#34;&gt;目的&lt;/h5&gt;

&lt;p&gt;一般来说InfluxDB不是为删除数据设计的。一个基本假设是，删除不频繁并且不必有高性能。然而，InfluxDB意识到清理过期数据
的必要性 &amp;mdash; 这就是RPs的目的。&lt;/p&gt;

&lt;h5 id=&#34;使用rps&#34;&gt;使用RPs&lt;/h5&gt;

&lt;p&gt;当您创建一个数据库的时候，InfluxDB自动创建一个名为&lt;code&gt;default&lt;/code&gt;的具有无限持续时间，并设置复制因子为1的RP，并且把它作为
默认&lt;code&gt;DEFAULT&lt;/code&gt;PR。当你写数据的时候没有提供一个明确的RP，数据会被设置为DEFAULT RP。&lt;/p&gt;

&lt;p&gt;InfluxDB自动查询并写入到DEFAULT RP的数据库。要查询或写入到不同的RP，你必使用&lt;code&gt;&amp;lt;database_name&amp;gt;.&amp;quot;&amp;lt;retention_policy&amp;gt;&amp;quot;.&amp;lt;measurement_name&amp;gt;&lt;/code&gt;
来完整的限定 database，retention policy 和 measurement name。&lt;/p&gt;

&lt;h4 id=&#34;2-3-2-a-name-21-a-连续查询&#34;&gt;2.3.2. &lt;a name=&#39;-21&#39;&gt;&lt;/a&gt;连续查询&lt;/h4&gt;

&lt;h5 id=&#34;定义-1&#34;&gt;定义&lt;/h5&gt;

&lt;p&gt;连续查询continuous query（CQ）是一个数据库中自动定期运行的InfluxQL查询。CQs需要一个&lt;code&gt;SELECT&lt;/code&gt;子句带有&lt;code&gt;GROUP BY time()&lt;/code&gt;
。 InfluxDB存储CQ的结果在一个的特定的measurement里。&lt;/p&gt;

&lt;h5 id=&#34;目的-1&#34;&gt;目的&lt;/h5&gt;

&lt;p&gt;CQs是定期缩减采样数据的最佳方案 - 一旦你执行CQ，InfluxDB运行定期的执行查询，不同于一个简单地返回结果的正常的查询，
InfluxDB把CQ的结果存储下来用于未来使用。&lt;/p&gt;

&lt;h5 id=&#34;使用cqs&#34;&gt;使用CQs&lt;/h5&gt;

&lt;p&gt;See Continuous Queries for a detailed discussion on how to create and manage CQs.&lt;/p&gt;

&lt;h4 id=&#34;2-3-3-a-name-rpsandcqs-22-a-结合-rps-and-cqs-一个案例研究&#34;&gt;2.3.3. &lt;a name=&#39;RPsandCQs--22&#39;&gt;&lt;/a&gt;结合 RPs and CQs - 一个案例研究&lt;/h4&gt;

&lt;p&gt;我们有通过电话，并通过网站以10秒间隔追踪食品订单到餐馆数量的实时数据。从长远来看，我们只关心30分钟时间间隔的数据。
在接下来的步骤中，我们使用RP和CQ，使InfluxDB：
- 自动删除两个小时以前的10秒级原始数据
- 自动汇总10秒数据到30分钟级数据
- 永久保留30分钟级数据&lt;/p&gt;

&lt;p&gt;处理的数据格式
- db=food_data
- measurement=orders
- fields=phone, website&lt;/p&gt;

&lt;h5 id=&#34;准备数据库&#34;&gt;准备数据库&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;在插入数据之前进行下面的两步，因为只有InfluxDB新数据进行CQ，也就是创建CQ之后产生的数据，&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;创建-default-rp&#34;&gt;创建&lt;code&gt;DEFAULT&lt;/code&gt; RP&lt;/h5&gt;

&lt;p&gt;我们希望DEFAULT RP是一个两小时的策略，而不是默认的&lt;code&gt;default&lt;/code&gt;策略：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; CREATE RETENTION POLICY two_hours ON food_data DURATION 2h REPLICATION 1 DEFAULT
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; SHOW RETENTION POLICIES ON food_data
name		      duration	  replicaN	  default
default		   0		        1		        false
two_hours	  2h0m0s		   1		        true
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;创建cq&#34;&gt;创建CQ&lt;/h5&gt;

&lt;p&gt;现在我们创建自动的缩减采样10秒级数据到30分钟级别的CQ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; CREATE CONTINUOUS QUERY cq_30m ON food_data BEGIN SELECT mean(website) AS mean_website,mean(phone)\
 AS mean_phone INTO food_data.&amp;quot;default&amp;quot;.downsampled_orders FROM orders GROUP BY time(30m) END
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注意指明了使用default RP，而不是two_hours RP&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;写入数据-查看结果&#34;&gt;写入数据，查看结果&lt;/h5&gt;

&lt;p&gt;写入数据到food_data一段时间后我们可以看到两个measurements：orders 和 downsampled_orders&lt;/p&gt;

&lt;p&gt;orders中的是10秒级别的two_hours RP下的原始数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; SELECT * FROM orders LIMIT 5
name: orders
-----------------
time						            phone 	website
2015-12-04T20:00:11Z	 1	     6
2015-12-04T20:00:20Z		9	     10
2015-12-04T20:00:30Z		2	     17
2015-12-04T20:00:40Z		3	     10
2015-12-04T20:00:50Z		1	     15
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在12/04/2015 at 22:08:19 UTC提交这个查询 - 发现最早的数据是不超过大约两小时前的时间戳。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：默认情况下，InfluxDB每隔30分钟检查执行RP。这是一个可配置的设置，请参阅数据库配置。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;downsampled_orders中的是default RP下的历史30分钟级别数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; SELECT * FROM food_data.&amp;quot;default&amp;quot;.downsampled_orders LIMIT 5
name: downsampled_orders
------------------------
time			               mean_phone		       mean_website
2015-12-03T22:30:00Z	 4.318181818181818	 9.254545454545454
2015-12-03T23:00:00Z	 4.266666666666667	 9.827777777777778
2015-12-03T23:30:00Z	 4.766666666666667	 9.677777777777777
2015-12-04T00:00:00Z	 4.405555555555556	 8.5
2015-12-04T00:30:00Z	 4.788888888888889	 9.383333333333333
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请注意，在downsampled_orders时间戳为30分钟的时间间隔，并且比orders旧的时间戳。&lt;/p&gt;

&lt;h3 id=&#34;2-4-a-name-23-a-硬件指南&#34;&gt;2.4. &lt;a name=&#39;-23&#39;&gt;&lt;/a&gt;硬件指南&lt;/h3&gt;

&lt;p&gt;略&lt;/p&gt;

&lt;h2 id=&#34;3-a-name-24-a-概念&#34;&gt;3. &lt;a name=&#39;-24&#39;&gt;&lt;/a&gt;概念&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>first blog</title>
      <link>http://u2takey.github.io/blog/first/</link>
      <pubDate>Sun, 24 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://u2takey.github.io/blog/first/</guid>
      <description>

&lt;h1 id=&#34;过去也写过一些博客-大都散落在各个平台-许多地方-有些遗失不见了&#34;&gt;过去也写过一些博客，大都散落在各个平台，许多地方，有些遗失不见了。&lt;/h1&gt;

&lt;h1 id=&#34;从今天开始它们会在这儿安家&#34;&gt;从今天开始它们会在这儿安家。&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>About Leiiwang</title>
      <link>http://u2takey.github.io/about/</link>
      <pubDate>Sat, 23 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://u2takey.github.io/about/</guid>
      <description>&lt;p&gt;一个没有脱离低级趣味的人。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang笔记之常见问题</title>
      <link>http://u2takey.github.io/blog/golang_faq/</link>
      <pubDate>Fri, 01 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://u2takey.github.io/blog/golang_faq/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;参考Golang&lt;a href=&#34;http://godoc.golangtc.com/doc/faq#Origins&#34;&gt;Frequently Asked Questions &lt;/a&gt;，很好的参考文档，理解Golang必读。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;!-- vscode-markdown-toc --&gt;

&lt;ul&gt;
&lt;li&gt;1. &lt;a href=&#34;#Golang-0&#34;&gt; Golang的特点和发起目的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2. &lt;a href=&#34;#Golang-1&#34;&gt;Golang设计原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;3. &lt;a href=&#34;#-2&#34;&gt;为什么没有泛型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;4. &lt;a href=&#34;#exceptions-3&#34;&gt; 为什么没有exceptions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;5. &lt;a href=&#34;#assertion-4&#34;&gt;为什么没有assertion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;6. &lt;a href=&#34;#buildconcurrencyontheideasofCSP-5&#34;&gt;为什么build concurrency on the ideas of CSP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;7. &lt;a href=&#34;#Whygoroutinesinsteadofthreads-6&#34;&gt;Why goroutines instead of threads&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;8. &lt;a href=&#34;#map-7&#34;&gt;为什么map非线程安全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;9. &lt;a href=&#34;#Golang-8&#34;&gt; Golang是面对对象语言吗&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;10. &lt;a href=&#34;#Golang-9&#34;&gt;为什么Golang没有运算符或者方法重载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;11. &lt;a href=&#34;#interfaceWhydoesnttypeTsatisfytheEqualinterface-10&#34;&gt; interface的一个有疑问的例子Why doesn&amp;rsquo;t type T satisfy the Equal interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;12. &lt;a href=&#34;#Errornil-11&#34;&gt;Error和nil的一个例子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;13. &lt;a href=&#34;#gotaggedoruntaggedunion-12&#34;&gt;go不支持tagged or untagged union&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;14. &lt;a href=&#34;#-13&#34;&gt;1为什么没有隐式类型转换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;15. &lt;a href=&#34;#Whyaremapsslicesandchannelsreferenceswhilearraysarevalues-14&#34;&gt; Why are maps, slices, and channels references while arrays are values?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;16. &lt;a href=&#34;#WhenshouldIuseapointertoaninterface-15&#34;&gt;When should I use a pointer to an interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;17. &lt;a href=&#34;#-16&#34;&gt; 关于闭包的一个例子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;18. &lt;a href=&#34;#:-17&#34;&gt;没有？:操作符&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /vscode-markdown-toc --&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;1-a-name-golang-0-a-golang的特点和发起目的&#34;&gt;1. &lt;a name=&#39;Golang-0&#39;&gt;&lt;/a&gt; Golang的特点和发起目的&lt;/h2&gt;

&lt;p&gt;Golang的特点以及要解决的问题概括起来就是三点:
1. concurrent : 多核 解决方式-&amp;gt; 语言层级并发, goroutine
2. garbage-collected language : c/c++的不足
3. fast compilation : c/c++等的不足, 依赖简单，类型系统简单，非传统OO。开发更简单快捷。
这种&lt;code&gt;简单设计&lt;/code&gt;的特点很容易让人和C++对比，对比C++就是砍了90%特性，减少90%的麻烦。更好的对比可能是C，better c with goroutine and garbage-collection。&lt;/p&gt;

&lt;h2 id=&#34;2-a-name-golang-1-a-golang设计原则&#34;&gt;2. &lt;a name=&#39;Golang-1&#39;&gt;&lt;/a&gt;Golang设计原则&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;felicity of programming ：  尽可能的简化代码编写规则，这点在各种解释语言，c++11等里面都可以体现一部分了，在golang上的体现就是如包的定义，编译安装，没有头文件，no forward declarations，:= 类型推断等等&lt;/li&gt;
&lt;li&gt;orthogonality of concepts ： 另一个原则是概念设计尽可能正交orthogonal，这样理解使用会更简单。 Methods can be implemented for any type; structures represent data while interfaces represent abstraction; and so on. Orthogonality makes it easier to understand what happens when things combine.当然一旦设计正交，需要的概念也变得很少。&lt;/li&gt;
&lt;li&gt;speed of compilation&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;3-a-name-2-a-为什么没有泛型&#34;&gt;3. &lt;a name=&#39;-2&#39;&gt;&lt;/a&gt;为什么没有泛型&lt;/h2&gt;

&lt;p&gt;Generics may well be added at some point. We don&amp;rsquo;t feel an urgency for them。为什么需要泛型可以参考&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-gj/&#34;&gt;这篇文章&lt;/a&gt;，但是泛型可以带来好处也会增加复杂度，golang可能以后会添加泛型支持，目前是一个open issue。&lt;/p&gt;

&lt;h2 id=&#34;4-a-name-exceptions-3-a-为什么没有exceptions&#34;&gt;4. &lt;a name=&#39;exceptions-3&#39;&gt;&lt;/a&gt; 为什么没有exceptions&lt;/h2&gt;

&lt;p&gt;这点是golang遭受用户(尤其是c++，java用户)诟病的重要原因，实际上Golang提供了panic,recover语法类似try catch。但是个人理解为什么没有只是一个选择问题，而不是技术问题。在很多语言的编码风格里尤其是Objective-C，一般都是使用Error Object来传递错误，虽然现在try catch的性能损失可以忽略不计，但是try catch的坏处是容易滥用，导致用户忽略error和exception的区别，另外Golang提供的多返回值也方便了error传递这种风格的使用，我个人对这种设计并不反感。&lt;/p&gt;

&lt;h2 id=&#34;5-a-name-assertion-4-a-为什么没有assertion&#34;&gt;5. &lt;a name=&#39;assertion-4&#39;&gt;&lt;/a&gt;为什么没有assertion&lt;/h2&gt;

&lt;p&gt;和没有exceptions有点类似： programmers use them as a crutch to avoid thinking about proper error handling and reporting，当然这种牵强的说法作者自己也有点没底气：We understand that this is a point of contention. There are many things in the Go language and libraries that differ from modern practices, simply because we feel it&amp;rsquo;s sometimes worth trying a different approach。&lt;/p&gt;

&lt;h2 id=&#34;6-a-name-buildconcurrencyontheideasofcsp-5-a-为什么build-concurrency-on-the-ideas-of-csp&#34;&gt;6. &lt;a name=&#39;buildconcurrencyontheideasofCSP-5&#39;&gt;&lt;/a&gt;为什么build concurrency on the ideas of CSP&lt;/h2&gt;

&lt;p&gt;（Communicating Sequential Processes）
一是Erlang，Occam 等的经验，二是便于语言层面构建。&lt;/p&gt;

&lt;h2 id=&#34;7-a-name-whygoroutinesinsteadofthreads-6-a-why-goroutines-instead-of-threads&#34;&gt;7. &lt;a name=&#39;Whygoroutinesinsteadofthreads-6&#39;&gt;&lt;/a&gt;Why goroutines instead of threads&lt;/h2&gt;

&lt;p&gt;把线程控制的复杂度从用户空间转移到语言层面（用户层面不需要关系协程还是线程，让并发的使用简单和高效是其设计目的）。&lt;a href=&#34;https://www.zhihu.com/question/20862617&#34;&gt;The Go scheduler&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;8-a-name-map-7-a-为什么map非线程安全&#34;&gt;8. &lt;a name=&#39;map-7&#39;&gt;&lt;/a&gt;为什么map非线程安全&lt;/h2&gt;

&lt;p&gt;知道map非线程安全就行了，这种设计大都是一个trade off&lt;/p&gt;

&lt;h2 id=&#34;9-a-name-golang-8-a-golang是面对对象语言吗&#34;&gt;9. &lt;a name=&#39;Golang-8&#39;&gt;&lt;/a&gt; Golang是面对对象语言吗&lt;/h2&gt;

&lt;p&gt;这个问题不太对，面对对象更多的是一种设计，而非语言特性，只是不同语言的实现和支持有所不同。在Golang里面的方式是interface，无type hierarchy, subclass的方式有点类似C，比C++等更general。同时Golang里面的Method也更general，可以给任何类型添加方法，总的来说的就是轻量级，更简单却能做更多事。个人觉得是Golang里最美的设计，面试官再问你会不会面对对象编程，你就打他脸。&lt;/p&gt;

&lt;h2 id=&#34;10-a-name-golang-9-a-为什么golang没有运算符或者方法重载&#34;&gt;10. &lt;a name=&#39;Golang-9&#39;&gt;&lt;/a&gt;为什么Golang没有运算符或者方法重载&lt;/h2&gt;

&lt;p&gt;没什么好说的，运算符和方法重载没什么用。即使在提供这类功能的语言里面也不要使用（除非一些极端场合如数据处理框架重载+*符号用于运算矩阵，这个场合非常少，更多时候这种功能大概会带来1%的便利和1000%的代码混乱和可读性降低）。&lt;/p&gt;

&lt;h2 id=&#34;11-a-name-interfacewhydoesnttypetsatisfytheequalinterface-10-a-interface的一个有疑问的例子why-doesn-t-type-t-satisfy-the-equal-interface&#34;&gt;11. &lt;a name=&#39;interfaceWhydoesnttypeTsatisfytheEqualinterface-10&#39;&gt;&lt;/a&gt; interface的一个有疑问的例子Why doesn&amp;rsquo;t type T satisfy the Equal interface&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;type Equaler interface {
    Equal(Equaler) bool
}
type T int
func (t T) Equal(u T) bool { return t == u } // does not satisfy Equaler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为Equaler的Equal函数需要的类型不同，正确的实现方式为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type T2 int
func (t T2) Equal(u Equaler) bool { return t == u.(T2) }  // satisfies Equaler

另一个例子
type Opener interface {
   Open() Reader
}

func (t T3) Open() *os.File
//T3 does not satisfy Opener, although it might in another language.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Golang没有自动类型转换，也没有多态（类之间），这也是作者的trade off&lt;/p&gt;

&lt;h2 id=&#34;12-a-name-errornil-11-a-error和nil的一个例子&#34;&gt;12. &lt;a name=&#39;Errornil-11&#39;&gt;&lt;/a&gt;Error和nil的一个例子&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;func returnsError() error {
	var p *MyError = nil
	if bad() {
		p = ErrBad
	}
	return p // Will always return a non-nil error.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这和interface的实现有关:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Under the covers, interfaces are implemented as two elements, a type and a value. The value, called the interface&amp;rsquo;s dynamic value, is an arbitrary concrete value and the type is that of the value. For the int value 3, an interface value contains, schematically, (int, 3).
An interface value is nil only if the inner value and type are both unset, (nil, nil). In particular, a nil interface will always hold a nil type. If we store a nil pointer of type *int inside an interface value, the inner type will be *int regardless of the value of the pointer: (*int, nil). Such an interface value will therefore be non-nil even when the pointer inside is nil.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;一个更直观点的例子
type myError struct{}
func (this *myError) Error() string { return &amp;quot;&amp;quot; }
var error1 *myError = nil
var error2 error = error1// to interface =&amp;gt; error2 != nil
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;13-a-name-gotaggedoruntaggedunion-12-a-go不支持tagged-or-untagged-union&#34;&gt;13. &lt;a name=&#39;gotaggedoruntaggedunion-12&#39;&gt;&lt;/a&gt;go不支持tagged or untagged union&lt;/h2&gt;

&lt;p&gt;untagged union不安全，tagged union或者Variant types, algebraic type则和interface有重合&lt;/p&gt;

&lt;h2 id=&#34;14-a-name-13-a-1为什么没有隐式类型转换&#34;&gt;14. &lt;a name=&#39;-13&#39;&gt;&lt;/a&gt;1为什么没有隐式类型转换&lt;/h2&gt;

&lt;p&gt;作者认为这种功能带来的隐患比便利要多，Golang中Int和int64都不是一个类型，不能隐式转换。&lt;/p&gt;

&lt;h2 id=&#34;15-a-name-whyaremapsslicesandchannelsreferenceswhilearraysarevalues-14-a-why-are-maps-slices-and-channels-references-while-arrays-are-values&#34;&gt;15. &lt;a name=&#39;Whyaremapsslicesandchannelsreferenceswhilearraysarevalues-14&#39;&gt;&lt;/a&gt; Why are maps, slices, and channels references while arrays are values?&lt;/h2&gt;

&lt;p&gt;知道这回事就行了slices的实现方式是对底层array的引用(见下图), &lt;a href=&#34;http://research.swtch.com/godata&#34;&gt;参考&lt;/a&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/astaxie/build-web-application-with-golang/master/zh/images/2.2.slice2.png&#34; alt=&#34;此处输入图片的描述&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;理解了上图再看这个例子就明白了
sa := make([]int, 10)
fmt.Println(&amp;quot;sa:&amp;quot;, saa)//saa: [0 0 0 0 0 0 0 0 0 0]
sb := saa[1:8]
sb[2] = 2
sb = append(sbb, 8) 
//sa 也被修改了
fmt.Println(&amp;quot;sa:&amp;quot;, sa, &amp;quot;sb:&amp;quot;, sb)// saa: [0 0 0 2 0 0 0 0 8 0] sbb: [0 0 2 0 0 0 0 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;16-a-name-whenshouldiuseapointertoaninterface-15-a-when-should-i-use-a-pointer-to-an-interface&#34;&gt;16. &lt;a name=&#39;WhenshouldIuseapointertoaninterface-15&#39;&gt;&lt;/a&gt;When should I use a pointer to an interface&lt;/h2&gt;

&lt;p&gt;Almost never.传一个指针指向interface大都数时候都是错误。另：The insight is that although a pointer to a concrete type can satisfy an interface, with one exception a pointer to an interface can never satisfy an interface.&lt;/p&gt;

&lt;h2 id=&#34;17-a-name-16-a-关于闭包的一个例子&#34;&gt;17. &lt;a name=&#39;-16&#39;&gt;&lt;/a&gt; 关于闭包的一个例子&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    done := make(chan bool)

    values := []string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;}
    for _, v := range values {
        go func() {
            fmt.Println(v)
            done &amp;lt;- true
        }()
    }

    // wait for all goroutines to complete before exiting
    for _ = range values {
        &amp;lt;-done
    }
}
// 输出是c c c 因为v共用一个变量 而输出取决于fmt.Println调用的时候v存储的数值
    // 正确的写法为
    for _, v := range values {
        go func(u string) {
            fmt.Println(u)
            done &amp;lt;- true
        }(v)
    }
    // 或者做一个本地拷贝
    for _, v := range values {
        v := v // create a new &#39;v&#39;. 注意位置 写在func里面还是不对
        go func() {
            fmt.Println(v)
            done &amp;lt;- true
        }()
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;18-a-name-17-a-没有-操作符&#34;&gt;18. &lt;a name=&#39;:-17&#39;&gt;&lt;/a&gt;没有？:操作符&lt;/h2&gt;

&lt;p&gt;差评&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Launchd Tutorial</title>
      <link>http://u2takey.github.io/blog/launchd/</link>
      <pubDate>Fri, 01 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://u2takey.github.io/blog/launchd/</guid>
      <description>

&lt;hr /&gt;

&lt;!-- vscode-markdown-toc --&gt;

&lt;ul&gt;
&lt;li&gt;1. &lt;a href=&#34;#LaunchdTutorial-0&#34;&gt; Launchd Tutorial&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;1.1. &lt;a href=&#34;#launchd-1&#34;&gt; 什么是launchd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.2. &lt;a href=&#34;#launchd-2&#34;&gt;为什么要launchd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.3. &lt;a href=&#34;#DaemonsandAgents-3&#34;&gt;Daemons and Agents&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.4. &lt;a href=&#34;#-4&#34;&gt;行为配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.5. &lt;a href=&#34;#-5&#34;&gt; 操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.6. &lt;a href=&#34;#recipes-6&#34;&gt;recipes（例子）&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;1.6.1. &lt;a href=&#34;#1app-7&#34;&gt;例1 app自动重启&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.6.2. &lt;a href=&#34;#2crontabstate-8&#34;&gt;例2 一个crontab任务（同时监控文件state）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.6.3. &lt;a href=&#34;#3inetd-9&#34;&gt;例3 一个inetd任务&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2. &lt;a href=&#34;#LaunchdSourcecode-10&#34;&gt; Launchd Sourcecode&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;2.1. &lt;a href=&#34;#-11&#34;&gt; 准备知识&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.2. &lt;a href=&#34;#launchctllist-12&#34;&gt; 命令launchctl list的运行流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.3. &lt;a href=&#34;#launchctlload-13&#34;&gt; 命令launchctl load的运行流程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3. &lt;a href=&#34;#-14&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /vscode-markdown-toc --&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;1-a-name-launchdtutorial-0-a-launchd-tutorial&#34;&gt;1. &lt;a name=&#39;LaunchdTutorial-0&#39;&gt;&lt;/a&gt; Launchd Tutorial&lt;/h2&gt;

&lt;h3 id=&#34;1-1-a-name-launchd-1-a-什么是launchd&#34;&gt;1.1. &lt;a name=&#39;launchd-1&#39;&gt;&lt;/a&gt; 什么是launchd&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;A unified, open-source service management framework for &lt;code&gt;starting, stopping and managing daemons, applications, processes, and scripts&lt;/code&gt;. Written and designed by Dave Zarzycki at Apple, it was introduced with Mac OS X Tiger and is licensed under the Apache License.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;1-2-a-name-launchd-2-a-为什么要launchd&#34;&gt;1.2. &lt;a name=&#39;launchd-2&#39;&gt;&lt;/a&gt;为什么要launchd&lt;/h3&gt;

&lt;p&gt;可以替代init，rc，init.d script，rc.d script，SystemStarter (OS X)，inetd / xinetd，crond / atd，watchdogd 而且使用更方便&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:footnote&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:footnote&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h3 id=&#34;1-3-a-name-daemonsandagents-3-a-daemons-and-agents&#34;&gt;1.3. &lt;a name=&#39;DaemonsandAgents-3&#39;&gt;&lt;/a&gt;Daemons and Agents&lt;/h3&gt;

&lt;p&gt;launchd 根据运行权限的不同,区分daemons(rootor the user specified with the key User)和agent(user)。&lt;/p&gt;

&lt;p&gt;不同的级别的daemon/agent存放位置也不同,其中/System/Library/为系统目录，不应该在此创建任何daemon/agent。第三方Library的目录在/Library/。而某个特别用户的目录在~/Library/&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Location&lt;/th&gt;
&lt;th&gt;Run on behalf of&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;User Agents&lt;/td&gt;
&lt;td&gt;~/Library/LaunchAgents&lt;/td&gt;
&lt;td&gt;Currently logged in user&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Global Agents&lt;/td&gt;
&lt;td&gt;/Library/LaunchAgents&lt;/td&gt;
&lt;td&gt;Currently logged in user&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Global Daemons&lt;/td&gt;
&lt;td&gt;/Library/LaunchDaemons&lt;/td&gt;
&lt;td&gt;root or the user specified with the key User&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;System Agents&lt;/td&gt;
&lt;td&gt;/System/Library/LaunchAgents&lt;/td&gt;
&lt;td&gt;Currently logged in user&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;System Daemons&lt;/td&gt;
&lt;td&gt;/System/Library/LaunchDaemons&lt;/td&gt;
&lt;td&gt;root or the user specified with the key User&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;1-4-a-name-4-a-行为配置&#34;&gt;1.4. &lt;a name=&#39;-4&#39;&gt;&lt;/a&gt;行为配置&lt;/h3&gt;

&lt;p&gt;daemon/agent的行为由一个property list定义。launchd提供了30多种配置项,full list请参考apple文档和 &lt;a href=&#34;http://launchd.info/&#34;&gt;http://launchd.info/&lt;/a&gt; ，这里简单介绍其中的几个。（可以用一个第三方工具LaunchControl配置）&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Key&lt;/th&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Label&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;job名字. 一般和plist名字相同,Required.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Program&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;执行程序路径. 如/Users/Me/Scripts/cleanup.sh.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ProgramArguments&lt;/td&gt;
&lt;td&gt;Array of strings&lt;/td&gt;
&lt;td&gt;Program 参数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;UserName&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;执行user名(defaults to root or current user)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RunAtLoad&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;td&gt;(defaults to NO) 标志任务是否要load进launchd立即启动&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;StartOnMount&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;td&gt;(defaults to NO)    标志任务是否要启动when a new filesystem is mounted.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;QueueDirectories&lt;/td&gt;
&lt;td&gt;Array of strings&lt;/td&gt;
&lt;td&gt;Watch a directory for new files&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;WatchPaths&lt;/td&gt;
&lt;td&gt;Array of strings&lt;/td&gt;
&lt;td&gt;Watch a filesystem path for changes. Can be a file or folder.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;StartInterval&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;Schedules job to run on a repeating schedule. Indicates number of seconds to wait between runs.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;StartCalendarInterval&lt;/td&gt;
&lt;td&gt;Dictionary of integers or Array of dictionaries of integers&lt;/td&gt;
&lt;td&gt;Job scheduling. The syntax is similar to cron.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;1-5-a-name-5-a-操作&#34;&gt;1.5. &lt;a name=&#39;-5&#39;&gt;&lt;/a&gt; 操作&lt;/h3&gt;

&lt;p&gt;所有行为都可以用一个命令行工具launchctl操作, 但使用LaunchControl更简单.下面列出了几个常见的操作。
####获取当前运行的所有demon/agent&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;host:~ user$ launchctl list 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####Loading a Job&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;launchctl load ~/Library/LaunchAgents/com.leiiwang.firsttest.plist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;com.leiiwang.firsttest.plist的内容:一个crontab任务，每分钟执行一次crontab-test.s，这个脚本只有一句话date.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;quot;&amp;gt;
&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
&amp;lt;dict&amp;gt;
        &amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;com.leiiwang.firsttest&amp;lt;/string&amp;gt;

        &amp;lt;key&amp;gt;ProgramArguments&amp;lt;/key&amp;gt;
        &amp;lt;array&amp;gt;
                &amp;lt;string&amp;gt;/Users/wangleo/bin/crontab-test.sh&amp;lt;/string&amp;gt;
        &amp;lt;/array&amp;gt;

        &amp;lt;key&amp;gt;KeepAlive&amp;lt;/key&amp;gt;
        &amp;lt;false/&amp;gt;

        &amp;lt;key&amp;gt;Nice&amp;lt;/key&amp;gt;
        &amp;lt;integer&amp;gt;1&amp;lt;/integer&amp;gt;

        &amp;lt;key&amp;gt;StartInterval&amp;lt;/key&amp;gt;
        &amp;lt;integer&amp;gt;60&amp;lt;/integer&amp;gt;

        &amp;lt;key&amp;gt;StandardErrorPath&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;/tmp/leiiwang.firsttest.err&amp;lt;/string&amp;gt;

        &amp;lt;key&amp;gt;StandardOutPath&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;/tmp/leiiwang.firsttest.out&amp;lt;/string&amp;gt;
&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出/tmp/leiiwang.firsttest.out&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Sat Dec 12 16:58:02 CST 2015
Sat Dec 12 16:59:02 CST 2015
Sat Dec 12 17:00:02 CST 2015
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####Unloading a Job&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;launchctl unload ~/Library/LaunchAgents/com.leiiwang.firsttest.plist
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-6-a-name-recipes-6-a-recipes-例子&#34;&gt;1.6. &lt;a name=&#39;recipes-6&#39;&gt;&lt;/a&gt;recipes（例子）&lt;/h3&gt;

&lt;h4 id=&#34;1-6-1-a-name-1app-7-a-例1-app自动重启&#34;&gt;1.6.1. &lt;a name=&#39;1app-7&#39;&gt;&lt;/a&gt;例1 app自动重启&lt;/h4&gt;

&lt;p&gt;这里用了macos 的open -W 命令.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;quot;&amp;gt;
&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
	&amp;lt;dict&amp;gt;
		&amp;lt;key&amp;gt;KeepAlive&amp;lt;/key&amp;gt;
		&amp;lt;true/&amp;gt;
		&amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt;
		&amp;lt;string&amp;gt;local.Safari.keepAlive&amp;lt;/string&amp;gt;
		&amp;lt;key&amp;gt;ProgramArguments&amp;lt;/key&amp;gt;
		&amp;lt;array&amp;gt;
			&amp;lt;string&amp;gt;/usr/bin/open&amp;lt;/string&amp;gt;
			&amp;lt;string&amp;gt;-W&amp;lt;/string&amp;gt;
			&amp;lt;string&amp;gt;/Applications/Safari.app&amp;lt;/string&amp;gt;
		&amp;lt;/array&amp;gt;
	&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-6-2-a-name-2crontabstate-8-a-例2-一个crontab任务-同时监控文件state&#34;&gt;1.6.2. &lt;a name=&#39;2crontabstate-8&#39;&gt;&lt;/a&gt;例2 一个crontab任务（同时监控文件state）&lt;/h4&gt;

&lt;p&gt;一个备份任务，在database运行的时候进行备份
使用PathState检测PID file是否存在确定任务特定任务database是否在执行
使用KeepAlive使得PID file存在时保持运行.
使用ThrottleInterval，任务终止后多久后重启&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;quot;&amp;gt;
&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
	&amp;lt;dict&amp;gt;
		&amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt;
		&amp;lt;string&amp;gt;com.example.app&amp;lt;/string&amp;gt;
		&amp;lt;key&amp;gt;Program&amp;lt;/key&amp;gt;
		&amp;lt;string&amp;gt;/Users/Me/Scripts/backup.sh&amp;lt;/string&amp;gt;
		&amp;lt;key&amp;gt;KeepAlive&amp;lt;/key&amp;gt;
		&amp;lt;dict&amp;gt;
			&amp;lt;key&amp;gt;PathState&amp;lt;/key&amp;gt;
			&amp;lt;dict&amp;gt;
				&amp;lt;key&amp;gt;/var/log/mysql.pid&amp;lt;/key&amp;gt;
				&amp;lt;true/&amp;gt;
			&amp;lt;/dict&amp;gt;
		&amp;lt;/dict&amp;gt;
		&amp;lt;key&amp;gt;ThrottleInterval&amp;lt;/key&amp;gt;
		&amp;lt;integer&amp;gt;3600&amp;lt;/integer&amp;gt;
	&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-6-3-a-name-3inetd-9-a-例3-一个inetd任务&#34;&gt;1.6.3. &lt;a name=&#39;3inetd-9&#39;&gt;&lt;/a&gt;例3 一个inetd任务&lt;/h4&gt;

&lt;p&gt;使用Sockets创建一个server监听13117&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
&amp;lt;dict&amp;gt;
  &amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;my.greeter&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;ProgramArguments&amp;lt;/key&amp;gt;
  &amp;lt;array&amp;gt;
    &amp;lt;string&amp;gt;/usr/bin/ruby&amp;lt;/string&amp;gt;
    &amp;lt;string&amp;gt;-e&amp;lt;/string&amp;gt;
    &amp;lt;string&amp;gt;puts &amp;quot;Hi #{gets.match(/(\w+)\W*\z/)[1]}, happy #{Time.now.strftime(&amp;quot;%A&amp;quot;)}!&amp;quot;&amp;lt;/string&amp;gt;
  &amp;lt;/array&amp;gt;
  &amp;lt;key&amp;gt;inetdCompatibility&amp;lt;/key&amp;gt;&amp;lt;dict&amp;gt;&amp;lt;key&amp;gt;Wait&amp;lt;/key&amp;gt;&amp;lt;false/&amp;gt;&amp;lt;/dict&amp;gt;
  &amp;lt;key&amp;gt;Sockets&amp;lt;/key&amp;gt;
  &amp;lt;dict&amp;gt;
    &amp;lt;key&amp;gt;Listeners&amp;lt;/key&amp;gt;
    &amp;lt;dict&amp;gt;
      &amp;lt;key&amp;gt;SockServiceName&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;13117&amp;lt;/string&amp;gt;
    &amp;lt;/dict&amp;gt;
  &amp;lt;/dict&amp;gt;
&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mac% launchctl load ~/Library/LaunchAgents/my.greeter.plist
mac% echo &amp;quot;My name is Leiiwang.&amp;quot; | nc localhost 13117
Hi Leiiwang, happy Saturday!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-a-name-launchdsourcecode-10-a-launchd-sourcecode&#34;&gt;2. &lt;a name=&#39;LaunchdSourcecode-10&#39;&gt;&lt;/a&gt; Launchd Sourcecode&lt;/h2&gt;

&lt;p&gt;整体感受是典型大公司代码，很多人修改的痕迹，各种bug修复和打补丁，搞得有点难看，但从整体上来看质量还算可以。&lt;/p&gt;

&lt;h3 id=&#34;2-1-a-name-11-a-准备知识&#34;&gt;2.1. &lt;a name=&#39;-11&#39;&gt;&lt;/a&gt; 准备知识&lt;/h3&gt;

&lt;p&gt;mach port: macos 的一种ipc类似一种消息队列和单向pipe的结合（macos在大部分版本中并不支持消息队列,大都时候mach port已经够好用了）,参见Ports, Port Rights, Port Sets, and Port Namespaces&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:footnote1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:footnote1&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;
kqueue: free bsd版本的epoll&lt;/p&gt;

&lt;h3 id=&#34;2-2-a-name-launchctllist-12-a-命令launchctl-list的运行流程&#34;&gt;2.2. &lt;a name=&#39;launchctllist-12&#39;&gt;&lt;/a&gt; 命令launchctl list的运行流程&lt;/h3&gt;

&lt;p&gt;launchctl是launchd提供的命令行工具,和其他类似的工具一样，launchctl作为一个server-client模式的client运行，client和server直接使用unix域套接字进行通信&lt;/p&gt;

&lt;p&gt;launchd中数据传输几乎只依赖一种数据结构_launch_data这种数据做array，dict,string&amp;hellip;作用,效率是很低的,但是也可以满足launchd的业务需求了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct _launch_data {
	uint64_t type;
	union {
		struct {
			union {
				launch_data_t *_array;
				char *string;
				void *opaque;
				int64_t __junk;
			};
			union {
				uint64_t _array_cnt;
				uint64_t string_len;
				uint64_t opaque_size;
			};
		};
		int64_t fd;
		uint64_t  mp;
		uint64_t err;
		int64_t number;
		uint64_t boolean;
		double float_num;
	};
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;client端流程
1. 在launchctl.c定义了各种的命令的对应运行函数,list的运行函数为list_cmd(..)
2. 构造一个msg，其key为LAUNCH_KEY_GETJOB
3. session相关
4. launchd_msg -&amp;gt; launchd_msg_internal -&amp;gt;launchd_msg_send:pack成一个launch_t结构
5. sendmsg通过socket发送命令结构体到server端
6. recvmsg通过socket读取返回&lt;/p&gt;

&lt;p&gt;server端流程
1. 在ipc.c创建了server并且通过kevent监听
2. kevent返回read事件,读取命令ipc_callback
3. launch_msg_recv
4. ipc_read_msg  -&amp;gt; ipc_read_msg2
5. core.c:job_export_all -&amp;gt;job_export_all2
6. 从rootmgr开始遍历，把所有job打包进一个dict并返回
7. launch_msg_send返回给客户端数据&lt;/p&gt;

&lt;h3 id=&#34;2-3-a-name-launchctlload-13-a-命令launchctl-load的运行流程&#34;&gt;2.3. &lt;a name=&#39;launchctlload-13&#39;&gt;&lt;/a&gt; 命令launchctl load的运行流程&lt;/h3&gt;

&lt;p&gt;这里我们特别的分析一种类似1.5 例子的简单任务的处理流程&lt;/p&gt;

&lt;p&gt;client端流程
1. 在launchctl.c定义了各种的命令的对应运行函数,load的运行函数为load_and_unload_cmd(..)
2. readfile：读取job配置的plist，检查几个必填key，读取到一个load_unload_state的结构体中
3. distill_job：对于watchpath/pathstate/queuedirectories任务特别处理，加入在watch job中
4. submit_job_pass,设置命令字为LAUNCH_KEY_SUBMIT_JOB
5. launchd_msg -&amp;gt; launchd_msg_internal -&amp;gt;launchd_msg_send:pack成一个launch_t结构
6. sendmsg通过socket发送命令结构体到server端
7. recvmsg通过socket读取返回&lt;/p&gt;

&lt;p&gt;server端流程
1. 前面步骤略
2. ipc_read_msg  -&amp;gt; ipc_read_msg2
3. core.c:job_import -&amp;gt;job_import_2 : 检查关键字,session相关&amp;hellip;
4. job_new:创建job,填充一个job_t结构,注意一些默认配置，设置callback
5. job_dispatch-&amp;gt;job_start 注意并不是所有的任务都会立即dispatch,start的,对于我们的这个任务同时根据配置加入了一个timer到kqueue，timer回调之后会再次dispatch-&amp;gt;start
6. job_start -&amp;gt; runtime_fork创建子进程,创建成功后父进程更新一些管理数据结构如actic_jobs等,并且把进程加入监听，监听进程的fork,exit等状态变化
7. 子进程运行startchild-&amp;gt;jobsetupattribute提取命令参数等，调用posix_spawn命令执行命令&lt;/p&gt;

&lt;h2 id=&#34;3-a-name-14-a-参考&#34;&gt;3. &lt;a name=&#39;-14&#39;&gt;&lt;/a&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://launchd.info/&#34;&gt;http://launchd.info/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://paul.annesley.cc/2012/09/mac-os-x-launchd-is-cool/&#34;&gt;http://paul.annesley.cc/2012/09/mac-os-x-launchd-is-cool/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Launchd&#34;&gt;https://en.wikipedia.org/wiki/Launchd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://alvinalexander.com/mac-os-x/launchd-examples-launchd-plist-file-examples-mac&#34;&gt;http://alvinalexander.com/mac-os-x/launchd-examples-launchd-plist-file-examples-mac&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:footnote&#34;&gt;The Ubuntu Linux distribution considered using launchd in 2006. launchd was rejected as an option because it was released under the Apple Public Source License
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:footnote&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:footnote1&#34;&gt;Ports, Port Rights, Port Sets, and Port NamespacesWith the exception of the task’s virtual address space, all other Mach resources are accessed through a level of indirection known as a port. A port is an endpoint of a unidirectional communication channel between a client who requests a service and a server who provides the service. If a reply is to be provided to such a service request, a second port must be used. This is comparable to a (unidirectional) pipe in UNIX parlance.In most cases, the resource that is accessed by the port (that is, named by it) is referred to as an object. Most objects named by a port have a single receiver and (potentially) multiple senders. That is, there is exactly one receive port, and at least one sending port, for a typical object such as a message queue.The service to be provided by an object is determined by the manager that receives the request sent to the object. It follows that the kernel is the receiver for ports associated with kernel-provided objects and that the receiver for ports associated with task-provided objects is the task providing those objects.For ports that name task-provided objects, it is possible to change the receiver of requests for that port to a different task, for example by passing the port to that task in a message. A single task may have multiple ports that refer to resources it supports. For that matter, any given entity can have multiple ports that represent it, each implying different sets of permissible operations. For example, many objects have a name port and a control port (sometimes called the privileged port). Access to the control port allows the object to be manipulated; access to the name port simply names the object so that you can obtain information about it or perform other non-privileged operations against it.Tasks have permissions to access ports in certain ways (send, receive, send-once); these are called port rights. A port can be accessed only via a right. Ports are often used to grant clients access to objects within Mach. Having the right to send to the object’s IPC port denotes the right to manipulate the object in prescribed ways. As such, port right ownership is the fundamental security mechanism within Mach. Having a right to an object is to have a capability to access or manipulate that object.Port rights can be copied and moved between tasks via IPC. Doing so, in effect, passes capabilities to some object or server.One type of object referred to by a port is a port set. As the name suggests, a port set is a set of port rights that can be treated as a single unit when receiving a message or event from any of the members of the set. Port sets permit one thread to wait on a number of message and event sources, for example in work loops.Traditionally in Mach, the communication channel denoted by a port was always a queue of messages. However, OS X supports additional types of communication channels, and these new types of IPC object are also represented by ports and port rights. See the section Interprocess Communication (IPC), for more details about messages and other IPC types.Ports and port rights do not have systemwide names that allow arbitrary ports or rights to be manipulated directly. Ports can be manipulated by a task only if the task has a port right in its port namespace. A port right is specified by a port name, an integer index into a 32-bit port namespace. Each task has associated with it a single port namespace.Tasks acquire port rights when another task explicitly inserts them into its namespace, when they receive rights in messages, by creating objects that return a right to the object, and via Mach calls for certain special ports (mach_thread_self, mach_task_self, and mach_reply_port.)
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:footnote1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>CoreData概要</title>
      <link>http://u2takey.github.io/blog/coredata/</link>
      <pubDate>Sun, 01 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://u2takey.github.io/blog/coredata/</guid>
      <description>

&lt;h1 id=&#34;注&#34;&gt;注&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;本文是学习中觉得比较重要的知识点的摘录,需要系统的学习请查看manual,需要速成教程本文的参考部分提供的几篇不错的文章。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;!-- vscode-markdown-toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#class-0&#34;&gt;一.入门&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#class-1&#34;&gt;1. 几个重要的概念/class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#DatamodelManagedObjects-1&#34;&gt;2. 定义数据:Data model＝》Managed Objects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#fetchManagedObjects.-2&#34;&gt;3.操作数据:添加、fetch、删除Managed Objects.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#class-2&#34;&gt;二.理解&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ManagedObjectModel-3&#34;&gt;1.理解 Managed Object Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ManagedObject-4&#34;&gt;2.理解 Managed Object&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ManagedObject2.3-5&#34;&gt;3.操作 Managed Object（2.3续）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Object:-6&#34;&gt;4.Object内存管理:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#RelationshipAndfetchproperties-7&#34;&gt;5.Relationship And fetch properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#UsingPersistentStores-8&#34;&gt;6. Using Persistent Stores&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#HowToPreloadandImportExistingData-9&#34;&gt;7.How To Preload and Import Existing Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#FetchedResultsControllerUITableView-10&#34;&gt;8.Fetched Results Controller&amp;lt;=&amp;gt;UITableView&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#class-3&#34;&gt;三.深入（走上人生巅峰）&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#Migrations-11&#34;&gt;1.Migrations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Multiplecontext-12&#34;&gt;2. Multiple context&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ConcurrencywithCoreData-13&#34;&gt;3. Concurrency with Core Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#CoreDataPerformance-14&#34;&gt;4.Core Data Performance 提高效率的一些提示&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#MultiplePersistentStoreCustomPersistentStore-15&#34;&gt;5.Multiple Persistent Store &amp;amp; Custom Persistent Store&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#NSPredicateNSExpression-16&#34;&gt;6.补充NSPredicate和NSExpression入门&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#-17&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#-18&#34;&gt;资源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#-19&#34;&gt;更新&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /vscode-markdown-toc --&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;a-name-class-0-a-一-入门-升职加薪&#34;&gt;&lt;a name=&#39;class-0&#39;&gt;&lt;/a&gt;一.入门（升职加薪）&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;coreData实现什么样的目的:类似archiving实现对象的保存和恢复&lt;/li&gt;
&lt;li&gt;coreData相比archiving等有什么样的优势:

&lt;ul&gt;
&lt;li&gt;managing changes of your model objects==&amp;gt;支持redo undo;支持对象之间的关系管理.&lt;/li&gt;
&lt;li&gt;节约内存,取一部分对象subset&lt;/li&gt;
&lt;li&gt;gui-based editor / setting of default values and attribute value validation&lt;/li&gt;
&lt;li&gt;disjoint sets of edits of your objects.-&amp;gt;不save 改变就是discard&lt;/li&gt;
&lt;li&gt;easy upgrade/migration.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;和&lt;code&gt;直接使用&lt;/code&gt;sqlite的不同

&lt;ul&gt;
&lt;li&gt;No primary keys means no foreign keys, either; Core Data manages the relationships between entities, or tables, and performs any necessary joins for you.&lt;/li&gt;
&lt;li&gt;core data本身不是ORM,是object graph management framework，它可以选择sqlite，xml，plist或是其他方式作为持久化方案;不能读取任意的sqlite文件&lt;/li&gt;
&lt;li&gt;方便支持undo,redo&lt;/li&gt;
&lt;li&gt;你只需要worry about data,而不是data storage mechanisms.(举个例子many to many的关系会导致core data自动创建一个关系表,如果直接使用sqlte你需要自己考虑并创建)
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;!!!注意:尽管不需要考虑存储机制,但是data model的设计还是需要深思熟虑的.Relational Database Normalization的规则在设计datamodel的时候同样需要被考虑。&lt;a href=&#34;http://support.microsoft.com/kb/283878/zh-cn&#34;&gt;一个简单的数据库标准化的参考&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;a-name-class-1-a-1-几个重要的概念-class&#34;&gt;&lt;a name=&#39;class-1&#39;&gt;&lt;/a&gt;1. 几个重要的概念/class&lt;/h2&gt;

&lt;h5 id=&#34;1-1-managed-object-model&#34;&gt;1.1 Managed Object Model:&lt;/h5&gt;

&lt;p&gt;You can think of this as the &lt;code&gt;database schema&lt;/code&gt;. It is a class that contains definitions for each of the objects (also called “Entities”) that you are storing in the database是描述应用程序的数据模型，这个模型包含实体（Entity），特性（Property），读取请求（Fetch Request）等. Usually, you will use the visual editor you just peeked at to set up what objects are in the database, what their attributes, and how they relate to each other. However, you can do this with code too!&lt;/p&gt;

&lt;h5 id=&#34;1-2-persistent-store-coordinator&#34;&gt;1.2 Persistent Store Coordinator:&lt;/h5&gt;

&lt;p&gt;You can think of this as the &lt;code&gt;database connection&lt;/code&gt;. Here’s where you set up the actual names and locations of what databases will be used to store the objects, and any time a managed object context needs to save something it goes through this single coordinator,处理底层的对数据文件的读取与写入。一般我们无需与它打交道.&lt;/p&gt;

&lt;h5 id=&#34;1-3-managed-object-context&#34;&gt;1.3 Managed Object Context:&lt;/h5&gt;

&lt;p&gt;You can think of this as a &lt;code&gt;“scratch pad”&lt;/code&gt;(object space) for objects that come from the database. It’s also the most important of the three for us, because we’ll be working with this the most. Basically, whenever you need to get objects, insert objects, or delete objects, you call methods on the managed object context (or at least most of the time!);Managed Object Context是Managed Object和其他CoreData模块的桥梁因此你应该总希望keep reference to it.&lt;/p&gt;

&lt;h5 id=&#34;1-4-managed-object&#34;&gt;1.4 Managed Object&lt;/h5&gt;

&lt;p&gt;代表一个Entity的类;&lt;/p&gt;

&lt;h5 id=&#34;1-5-entity-description&#34;&gt;1.5 Entity Description&lt;/h5&gt;

&lt;p&gt;注意理解这样的概念Entity是数据,但是它同时又是一个抽象的概念,他必须有实体的类来描述和代表他.一个Entity Description就是用来描述这个Entity的,描述的目的可能是为了对Entity进行fetch等相关操作等;而Entity取出来了之后又需要一个实体类来代表它,这个类就是一个managed object类.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//Managed Object Model--包含-》Entity Description&amp;lt;---Entity---&amp;gt;managed object;
//见图1.2,1.3.managed object和Entity Description

//你可以从datamodel获取Entity Description
NSEntityDescription *employeeEntity = [[managedObjectModel entitiesByName] objectForKey:@&amp;quot;Employee&amp;quot;];

//也可以从context直接获取
NSEntityDescription *employeeEntity = [NSEntityDescription entityForName:@&amp;quot;Employee&amp;quot; inManagedObjectContext:context];

// Entity Description 和managed object是彼此关联的 可以通过Entity Description得到managed object
// 也可以
&lt;/code&gt;&lt;/pre&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/24752_1314847532b1OE.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;Figure 1-1  A simple Core Data stack—1&lt;/p&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/2000.jpg&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;Figure 1-2  A simple Core Data stack-2&lt;/p&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/20001.jpg&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;Figure 1-3  Managed objects in a context, and a table in the persistent store&lt;/p&gt;

&lt;h2 id=&#34;a-name-datamodelmanagedobjects-1-a-2-定义数据-data-model-managed-objects&#34;&gt;&lt;a name=&#39;DatamodelManagedObjects-1&#39;&gt;&lt;/a&gt;2. 定义数据:Data model＝》Managed Objects&lt;/h2&gt;

&lt;h5 id=&#34;2-1-subclass-of-nsmanagedobject-可以看成是数据表的一个record-a-record-in-a-table-in-a-database&#34;&gt;2.1. (Subclass of)NSManagedObject 可以看成是数据表的一个record。a record in a table in a database.&lt;/h5&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/20002.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;h5 id=&#34;2-2-nsmanagedobjectmodel和-nsmanagedobject的关系-model是描述数据模型的schema-是一组entity-description-objects-instances-of-nsentitydescription-的集合-一个entity-description描述一个entity-a-table-in-a-database&#34;&gt;2.2. NSManagedObjectModel和 NSManagedObject的关系:model是描述数据模型的schema,是一组entity description objects (instances of NSEntityDescription)的集合; 一个entity description描述一个entity (a table in a database).&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;当datamodel变化的时候core data不能读取数据-&amp;gt;类似的存储方式都有类似问题,coredata提供了管理这种变化的方法&amp;ndash;&lt;a href=&#34;http://genekc07.stowers.org/Users/mec/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.AppleiOS5_1.iOSLibrary.docset/Contents/Resources/Documents/documentation/Cocoa/Conceptual/CoreDataVersioning/Articles/Introduction.html#//apple_ref/doc/uid/TP40004399&#34;&gt;Core Data Model Versioning and Data Migration Programming Guide&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/20003.jpg&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;Figure 2-1 illustrates the relationship between an entity description in a model, a table in the database, and a managed object corresponding to a single record in the table.&lt;/p&gt;

&lt;h5 id=&#34;2-3-with-core-data-you-cannot-retrieve-only-certain-attributes-of-an-object-you-have-to-retrieve-the-entire-object-也就是说不能像数据库一样只拿出一项中的部分列出来-如果要实现这样的功能需要-factor-the-objects-into-serverral-pieces-把对象分成几部分&#34;&gt;2.3. With Core data you cannot retrieve only certain attributes of an object – you have to retrieve the entire object. 也就是说不能像数据库一样只拿出一项中的部分列出来,如果要实现这样的功能需要 factor the objects into serverral pieces 把对象分成几部分.&lt;/h5&gt;

&lt;h5 id=&#34;2-4-auto-generating-model-files-自动生成数据object的oc文件-也可以不使用-用setvalueforkey解决&#34;&gt;2.4. Auto Generating Model Files:自动生成数据object的oc文件(也可以不使用 用setvalueforkey解决)&lt;/h5&gt;

&lt;p&gt;使用自动生成的subclass of NSManagedObject有什么好处:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Better support from the development tools.(You get code completion for property accessor methods, and compile-time type- and symbol-checking;这就是为什么在自动生成的class里头属性都声明为dynamic,coredate自动runtime生成accessor;同时也没有delloc因为生命周期由coredata管理&amp;ndash;自己新建要自己管理)&lt;/li&gt;
&lt;li&gt;Support for custom methods for the entity.(In many situations, you want to provide special logic for the entity, such as validation methods or derived properties)&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;生成完成之后你会发现datamodel里的entity class也被自动更新了.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;2-5-managed-objects-entity-的一些属性&#34;&gt;2.5.Managed Objects / Entity 的一些属性&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;NSEntityDescription:是一个Entity的描述,而Entity是一个抽象的概念,并没有Entity这样一个类,Entity代表了&lt;code&gt;数据&lt;/code&gt;,可以继承Entity,使用abstract entity;Entity是与NSManagedObject这个&lt;code&gt;class&lt;/code&gt;对应的(但是并不完全等同),一个Entity由NSManagedObject代表;而一个Entity的&lt;code&gt;instance&lt;/code&gt;由一个NSManagedObject的实例代表,实际理解中可以把Entity等同于代表其的NSManagedObject class。Abstract Entities - you will not create any instances of that entity.&lt;/li&gt;
&lt;li&gt;NSEntityDescription 有属性 NSAttributeDescription 和 NSRelationshipDescription,NSFetchedPropertyDescription 用于描述Entity在schema中的特点.&lt;/li&gt;
&lt;li&gt;Properties:对象的属性,包括Attribute,Relationship,Fetched Property&lt;/li&gt;
&lt;li&gt;Attribute可以是transient说明实际不会被保存,一般是runtime的时候生成的.Index/optional类似数据库中的概念类似.可以设置类型和validation。但是不建议设置optinal,尤其是数值类型的,尽量不设置optinal并设置default value因为数据库中的NULL不同于0或者@&amp;ldquo;&amp;rdquo; (数据库中的NULL取出来对应nil并没有问题,predicate也可以设置nil,但是nil = 0这样会造成混淆&amp;ndash;nil=NULL=Nil=0,[NSNull null]!=0);另:保存为transformable是用二进制/nsdata/BLOB来保存数据,通常来说不是一个好的选择,和binary data类型区别仅仅是多了一个转换过程(比如nscolor可以转成字符串或16进制数而不是nsdata,二进制不易于查询)&lt;/li&gt;
&lt;li&gt;fetch property:Relationship 在对象中变成对应关系的指针,使用时load对应的数据.Fetched properties represent weak, one-way relationships.&lt;/li&gt;
&lt;li&gt;Fetch Request Templates:是常用的Fetch Request,用的时候从datamodel获取即可直接使用 managedObjectModel.fetchRequestTemplatesByName[@&amp;ldquo;FetchRequestName&amp;rdquo;]&lt;/li&gt;
&lt;li&gt;User Info Dictionaries:和datamode绑定的其他任意信息.&lt;/li&gt;
&lt;li&gt;Configurations:一般用于多个数据store（详解见第二部分）。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Managed Object Model 抽象&lt;/th&gt;
&lt;th&gt;NSManagedObjectModel&lt;/th&gt;
&lt;th&gt;数据模型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Entity&lt;/td&gt;
&lt;td&gt;NSEntityDescription&lt;/td&gt;
&lt;td&gt;抽象数据类型，相当于数据库中的表&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Property&lt;/td&gt;
&lt;td&gt;NSPropertyDescription Entity&lt;/td&gt;
&lt;td&gt;特性，相当于数据库表中的一列&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;gt; Attribute&lt;/td&gt;
&lt;td&gt;NSAttributeDescription&lt;/td&gt;
&lt;td&gt;基本数值型属性（如Int16,BOOL,Date等类型的属性）非标准Transformable&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;gt; Relationship&lt;/td&gt;
&lt;td&gt;NSRelationshipDescription&lt;/td&gt;
&lt;td&gt;属性之间的关系&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;gt; Fetched Property&lt;/td&gt;
&lt;td&gt;NSFetchedPropertyDescription&lt;/td&gt;
&lt;td&gt;查询属性（类似一种单向关系，易用查询）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/20004.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    






    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/20005.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;Figure 2-2  Entity description with two attributes and a relationship&lt;/p&gt;

&lt;h2 id=&#34;a-name-fetchmanagedobjects-2-a-3-操作数据-添加-fetch-删除managed-objects&#34;&gt;&lt;a name=&#39;fetchManagedObjects.-2&#39;&gt;&lt;/a&gt;3.操作数据:添加、fetch、删除Managed Objects.&lt;/h2&gt;

&lt;h5 id=&#34;3-1-添加-insertnewobjectforentityforname-inmanagedobjectcontext-获得对应的managedobject-修改属性-save&#34;&gt;3.1 添加:insertNewObjectForEntityForName:inManagedObjectContext: 获得对应的ManagedObject-》修改属性 (-》save)&lt;/h5&gt;

&lt;h5 id=&#34;3-2-fetch-需要一个fetch-request-设置其nsentitydescription-predicate-sort-descriptor-类似一个select语句-open-the-scheme-drop-down-in-xcode-and-select-edit-scheme-select-the-run-scheme-and-select-the-arguments-tab-add-the-following-argument-com-apple-coredata-sqldebug-1-这样可以让你看到原始的select语句&#34;&gt;3.2 Fetch:需要一个fetch request,设置其NSEntityDescription,predicate,sort descriptor＝》类似一个select语句(Open the Scheme drop-down in Xcode and select ‘Edit Scheme…’. Select the ‘Run’ scheme and select the ‘Arguments’ tab. Add the following argument: “-com.apple.CoreData.SQLDebug 1”.这样可以让你看到原始的select语句)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;NSFetchedResultsController用于为tableviewfetch数据,经过了优化可以节约大量代码以及保证效率和内存上的优化.&lt;/li&gt;
&lt;li&gt;You cannot fetch using a predicate based on transient properties&lt;/li&gt;
&lt;li&gt;可以fetch特定的object用来检查是不是被删掉了 感觉使用场景不是很高[NSPredicate predicateWithFormat:@&amp;ldquo;self == %@&amp;rdquo;, targetObject];也可以使用@&amp;ldquo;self IN %@&amp;rdquo;,arrayOfManagedObjectIDs&lt;/li&gt;
&lt;li&gt;如果要fetch一个特定的比如value是最大值的可以使用 NSExpression(详见programing guide)&lt;/li&gt;
&lt;li&gt;fetch 设置成 super-entity 的时候会得到满足要求的所有sub-entities和super-entity(如果不是abstract的)&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;3-3-删除-managedobjectcontext-deleteobject-save-删除的时候需要考虑relationship不同的relationship删除策略不一样&#34;&gt;3.3 删除: managedObjectContext deleteObject: (-》save)(删除的时候需要考虑relationship不同的relationship删除策略不一样)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;删除会发送 NSManagedObjectContextObjectsDidChangeNotification&lt;/li&gt;
&lt;/ul&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/20006.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;h5 id=&#34;3-4-操作关系属性-得到关系属性的时候获得的是一个fault-object&#34;&gt;3.4 操作关系属性:得到关系属性的时候获得的是一个fault object&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;一对一关系:&lt;/li&gt;
&lt;li&gt;一(多)对多关系:&lt;/li&gt;
&lt;li&gt;一个隐含的知识点:当你取得一个关系的object的时候没有必要设置一个fetch,会自动帮你取得(开始是个fault)
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;// 使用KVC
NSMutableSet *employees = [aDepartment mutableSetValueForKey:@&amp;quot;employees&amp;quot;];
[employees addObject:newEmployee];
[employees removeObject:firedEmployee];


// or 使用自动生成的关系操作方法
[aDepartment addEmployeesObject:newEmployee];
[aDepartment removeEmployeesObject:firedEmployee];

//1.是.employees返回的是set 和 mutableSetValueForKey 返回的有所不同 操作这个set
// KVO change notifications are not emitted and the inverse relationship is not updated correctly.
[aDepartment.employees addObject:newEmployee]; // do not do this!
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;值得注意的是:无论是添加 还是 删除 对managedObjectContext 操作的同时还需要对你用于缓存的datasource进行同样的操作.managedObjectContext 会缓存object 必要的时候 可以 managedObjectContext refreshObject:mergeChanges/reset可以清空缓存以节约内存,同时可用[[context registeredObjects] count]查看.&lt;/p&gt;
&lt;/blockquote&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/20007.gif&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;Figure 3-1 fetch request 示意&lt;/p&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/20008.jpg&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;Figure 3-2 fetch 流程&lt;/p&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/20009.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;h1 id=&#34;a-name-class-2-a-二-理解-迎娶白富美&#34;&gt;&lt;a name=&#39;class-2&#39;&gt;&lt;/a&gt;二.理解（迎娶白富美）&lt;/h1&gt;

&lt;h2 id=&#34;a-name-managedobjectmodel-3-a-1-理解-managed-object-model&#34;&gt;&lt;a name=&#39;ManagedObjectModel-3&#39;&gt;&lt;/a&gt;1.理解 Managed Object Model&lt;/h2&gt;

&lt;h5 id=&#34;1-1-创建managed-object-model-可以使用xib或者完全使用code&#34;&gt;1.1 创建Managed Object Model:可以使用xib或者完全使用code&lt;/h5&gt;

&lt;h5 id=&#34;1-2-compiling-model-xcdatamodeld是-deployment-resource-经过特殊的编译器-momc-编译-成为-mom文件-momd是文件夹&#34;&gt;1.2 Compiling Model:xcdatamodeld是 deployment resource 经过特殊的编译器 momc 编译 成为 mom文件(momd是文件夹)&lt;/h5&gt;

&lt;h5 id=&#34;1-3-loading-model-两种方法initwithcontentsofurl-指定url-preferred-mergedmodelfrombundles-如果不需要分开model的时候&#34;&gt;1.3 Loading Model:两种方法initWithContentsOfURL (指定url,preferred)/ mergedModelFromBundles (如果不需要分开model的时候)&lt;/h5&gt;

&lt;h5 id=&#34;1-4-change-model-如果还需要访问existing-stores中的数据就不能直接修改model-而是应该-have-a-versioned-model-修改时创建一个新的version-model旧的不动&#34;&gt;1.4 Change Model:如果还需要访问existing stores中的数据就不能直接修改Model，而是应该 have a versioned model;修改时创建一个新的version model旧的不动&lt;/h5&gt;

&lt;h5 id=&#34;1-5-localizing-model-providing-localizationdictionary&#34;&gt;1.5 Localizing Model:providing localizationDictionary&lt;/h5&gt;

&lt;p&gt;


    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/200010.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    





    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/200011.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    

&lt;/p&gt;

&lt;h2 id=&#34;a-name-managedobject-4-a-2-理解-managed-object&#34;&gt;&lt;a name=&#39;ManagedObject-4&#39;&gt;&lt;/a&gt;2.理解 Managed Object&lt;/h2&gt;

&lt;h5 id=&#34;2-1-概念-managed-object是nsmanagedobject的instance-associated-with-an-entity-description-an-instance-of-nsentitydescription-associated-with-a-managed-object-context-record-和-object是一对多的关系-因为可能有几个context等情况-几个object可能对应的是同一个数据&#34;&gt;2.1 概念:Managed Object是NSManagedObject的instance / associated with an entity description (an instance of NSEntityDescription)/ associated with a managed object context /record 和 object是一对多的关系,因为可能有几个context等情况,几个object可能对应的是同一个数据&lt;/h5&gt;

&lt;h5 id=&#34;2-2-object-accessor&#34;&gt;2.2 Object Accessor:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;自动生成Accessor(注:如果你自己写Accessor, dynamically-generated method snever replace your own code.);&lt;/li&gt;
&lt;li&gt;基于KVO;&lt;/li&gt;
&lt;li&gt;没有执行NSCopying协议&lt;/li&gt;
&lt;li&gt;weak会被当成strong,只能用strong和copy&lt;/li&gt;
&lt;li&gt;To Many Relation会变成NSSet;同样自动生成catgory方法;&lt;/li&gt;
&lt;li&gt;dynamic的方法子类不能super&lt;/li&gt;
&lt;li&gt;如果要自定义accessor方法需要符合特定的规则:按照顺序调用&lt;code&gt;relevant access and KVO change notification methods&lt;/code&gt;(Important: You are strongly encouraged to use dynamic properties)见下面的代码示例.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;2-3-managed-object-和其他对象有三点主要不同&#34;&gt;2.3 Managed Object 和其他对象有三点主要不同:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;instance of (subclass of) NSManagedObject&lt;/li&gt;
&lt;li&gt;Exists in an environment defined by its &lt;code&gt;managed object context&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Has an associated &lt;code&gt;entity description&lt;/code&gt; that describes the properties of the object&lt;/li&gt;
&lt;li&gt;(核心元素是一个context一个entity description)&lt;/li&gt;
&lt;li&gt;(创建不用alloc;初始化不重载init见3.1)
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt; @interface Department (PrimitiveAccessors)
  - (NSString *)primitiveName;
  - (void)setPrimitiveName:(NSString *)newName;
  @end

 
- (NSString *)name
{
      [self willAccessValueForKey:@&amp;quot;name&amp;quot;];
      NSString *myName = [self primitiveName];
      [self didAccessValueForKey:@&amp;quot;name&amp;quot;];
      return myName;
}
- (void)setName:(NSString *)newName
{
      [self willChangeValueForKey:@&amp;quot;name&amp;quot;];
      [self setPrimitiveName:newName];
      [self didChangeValueForKey:@&amp;quot;name&amp;quot;];
}


//类似的当你想实现一个scalar type (NSInteger or CGFloat), or one supported by NSKeyValueCoding (NSRect, NSPoint, NSSize, NSRange),

@property CGFloat radius;

- (CGFloat)radius
  {
      [self willAccessValueForKey:@&amp;quot;radius&amp;quot;];
      float f = _radius;//数据库取出存在_radius =&amp;gt; 转换成 float
      [self didAccessValueForKey:@&amp;quot;radius&amp;quot;];
      return f;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-managedobject2-3-5-a-3-操作-managed-object-2-3续&#34;&gt;&lt;a name=&#39;ManagedObject2.3-5&#39;&gt;&lt;/a&gt;3.操作 Managed Object（2.3续）&lt;/h2&gt;

&lt;h5 id=&#34;3-1-managed-object-ids-and-uris&#34;&gt;3.1 Managed Object IDs and URIs&lt;/h5&gt;

&lt;p&gt;A managed object ID uniquely identifies the same managed object both between managed object contexts in a single application, and in multiple applications (as in distributed systems);创建的时候是temporary的可以用isTemporaryID测试.类似表里的primary key但是范围更大.可以转换成url的形式URIRepresentation通过他们可以直接获取对应的object;甚至可以在不同的store里传递&lt;/p&gt;

&lt;h5 id=&#34;3-2-validation&#34;&gt;3.2 Validation&lt;/h5&gt;

&lt;p&gt;需要指出的是，&lt;code&gt;KVC是不会自动调用键值验证方法的&lt;/code&gt;，就是说我们需要手动验证。&lt;code&gt;但是有些技术，比如CoreData会自动调用&lt;/code&gt;。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Property-Level Validation：下面的第一个方法&lt;/li&gt;
&lt;li&gt;Inter-Property validation: 下面的第2-4个方法;提供了更多validation;和Property-Level Validation不同的是,validation的关注点在于不同的combination是不是符合要求;注意要类似[super validateForInsert:error]先运行父类的方法to ensure that individual property validation methods are also invoked&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;//如下的4个方法在Managed Object的生命周期会自动触发 
// validateValue 会自动调用- (BOOL)validate&amp;lt;Key&amp;gt;:error: (可以重载他而不要直接重载validateValue)
- (BOOL)validateValue:(id *)value forKey:(NSString *)key error:(NSError **)error;    // KVC

// 下面三个是Inter-Property validation 提供了更多的validate的机会
- (BOOL)validateForDelete:(NSError **)error;
- (BOOL)validateForInsert:(NSError **)error;
- (BOOL)validateForUpdate:(NSError **)error;
// 要注意的一个问题是:对于error的处理,error可能是已经存在的,这时候需要添加error信息而不是重新赋值
//be sure to combine errors and not overwrite them
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;3-3-faults&#34;&gt;3.3 Faults&lt;/h5&gt;

&lt;p&gt;In some situations a managed object may be a “fault”—an object whose property values have not yet been loaded from the external store. When you access persistent property values, a fault “fires” and its persistent data is retrieved automatically from the store.可以手动把一个方法变成fault:NSManagedObjectContext&amp;rsquo;s refreshObject:mergeChanges:.比方说object的一个关系属性在没使用的时候就是一个fault。&lt;/p&gt;

&lt;h5 id=&#34;3-4-ensuring-data-is-up-to-date&#34;&gt;3.4 Ensuring Data Is Up-to-Date&lt;/h5&gt;

&lt;p&gt;refreshObject:mergeChanges:根据mergeChanges的flag操作是merge还是变成fault;注意transient的属性刷新之后会变成pre-refresh value after awakeFromFetch is invoked；为了保证transient的属性是最新的可以设置**IsValiddid属性并在TurnIntoFault方法里写成NO&lt;/p&gt;

&lt;h5 id=&#34;3-5-不同context-copy-and-paste&#34;&gt;3.5 不同context copy and paste&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;NSManagedObjectID *objectID = [managedObject objectID];
NSManagedObject *copy = [context2 objectWithID:objectID];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-object-6-a-4-object内存管理&#34;&gt;&lt;a name=&#39;Object:-6&#39;&gt;&lt;/a&gt;4.Object内存管理:&lt;/h2&gt;

&lt;h5 id=&#34;4-1-managed-object和context&#34;&gt;4.1 Managed Object和Context&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;两者是关联的,但是关系是weak的。不过context在其中的Managed Object的pending transaction/reset/rollback之前是有strong reference的(undomanager在之后都有strong reference);&lt;/li&gt;
&lt;li&gt;设置setRetainsRegisteredObjects可以是使得Managed Object依赖与context(但是一般不会这么做,因为你自己可以设置一个NSArray之类的集合来管理你的数据的生命周期)&lt;/li&gt;
&lt;li&gt;使用上面讲过的refreshObject:mergeChanges也可以用来打破object之间的retain cycle&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;4-2-object-life-cycle&#34;&gt;4.2  Object Life-Cycle&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;init:three different ways you can customize initialization —by overriding initWithEntity: insertIntoManagedObjectContext:, awakeFromInsert, or awakeFromFetch 不要override init ;推荐使用awakeFromInsert, or awakeFromFetch分别在insetNew和fetch方法之后被执行&lt;/li&gt;
&lt;li&gt;validate:not override validateValue:forKey:error: ; override validate&lt;Key&gt;:error:. If you want to validate inter-property values, you can override validateForUpdate: and/or related validation methods; validateValue:forKey:error: 内部会自动调用 validate&lt;Key&gt;:error:&lt;/li&gt;
&lt;li&gt;delloc:不要重载delloc;core data负责释放资源,释放之前调用didTurnIntoFault;可以重载didTurnIntoFault&lt;/li&gt;
&lt;li&gt;fault:an object whose property values have not yet been loaded from the external data store
1.你的datasource何时被释放
2.context的cache何时释放&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;4-3-faulting-and-uniquing&#34;&gt;4.3  Faulting and Uniquing&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;A fault is a placeholder object that represents 1)&lt;code&gt;a managed object that has not yet been fully realized&lt;/code&gt;, or 2)&lt;code&gt;a collection object that represents a relationship&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;fault的使用相当于lazy loading除非使用否则不需要真正的fetch,这样就减少了内存使用.fetch的动作叫做fire the fault.如果是fault那么可能是下面说的情况2)在缓存中，3)不在缓存中,需要fetch 可以用isFault测试,如果是NO那么肯定是情况1)

&lt;ul&gt;
&lt;li&gt;1)对象已经在 context 中，这种操作基本上是没有任何代价的。&lt;/li&gt;
&lt;li&gt;2)对象不在 context 中，但是因为你最近从 store 中取出过对象，所以持久化存储协调器缓存了对象的值。这个操作还算廉价（但是，一些操作会被锁住）。操作耗费最昂贵的情况是&lt;/li&gt;
&lt;li&gt;3)当 context 和持久化存储协调器都是第一次访问这个对象，这种情况必须通过 store 从 SQLite 数据库取回。&lt;/li&gt;
&lt;li&gt;注意区别fault和cache的区别,变成fault还是占内存的,只是变成一个类似指针的占位符,然后fault
之后可能会释放所有对它的reference,这时会将其清除出cache,不占任何内存;(分别用refeash和reset强制控制)。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;refreshObject:mergeChanges:可以手动把一个object变成fault=&amp;gt;会发出 didTurnIntoFault 的message;可以重载做&amp;rdquo;housekeeping&amp;rdquo;类的一些操作; key-value observing (KVO) change notifications也会被sent&lt;/li&gt;
&lt;li&gt;Uniquing是保证an entry in a persistent store is associated with only one managed object的技术&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;a-name-relationshipandfetchproperties-7-a-5-relationship-and-fetch-properties&#34;&gt;&lt;a name=&#39;RelationshipAndfetchproperties-7&#39;&gt;&lt;/a&gt;5.Relationship And fetch properties&lt;/h2&gt;

&lt;h5 id=&#34;5-1-relationship定义&#34;&gt;5.1 Relationship定义&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Relationship可以同时是optional的又设置上下限,意思是可以不存在,但是如果存在那么就要满足上下限要求&lt;/li&gt;
&lt;li&gt;Relationship Delete Rules:Deny;Nullify;Cascade;No Action几种rule觉得delete对象时的操作(很好理解详见programming guide -p84)。当你移动,删除一个带有关系的object的时候,coredata 会自动为你检查规则和更新关系.&lt;/li&gt;
&lt;li&gt;programming guide -p84有一个many to many的例子,大多时候数据库效率不高或者难于使用并不是framework的问题,而是设计不合理。&lt;/li&gt;
&lt;li&gt;Relationship一般都是双向的,创建一个单向的relationship基本没什么好处.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;5-2-fetched-properties&#34;&gt;5.2 Fetched Properties&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Fetched properties represent weak, one-way relationships但是不同的是fetch语句实现的,因此是array，evaluated lazily;&lt;/li&gt;
&lt;li&gt;Fetched properties和fetch request template都是fetch语句,不同的是Fetched properties会cache fetch的object（这里要注意keep data up-to-date）;同时Fetched properties一般用在fetch 不同的table之间的元素;fetch request template;fetch的是一个table里的元素 两者都可以在代码里通过一个fetch语句实现&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;5-3-例子-获得一组数据中创建日期最早的那个的日期&#34;&gt;5.3 例子 获得一组数据中创建日期最早的那个的日期&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;方法1:fetch所有的排序,取第一个;===&amp;gt;设置fetch limit只取一个&lt;/li&gt;
&lt;li&gt;方法2:fetch所有的排序,取第一个;和1不同的是只fetch日期这个字段&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;[fetchRequest setResultType:NSDictionaryResultType]; 
[fetchRequest setPropertiesToFetch:[NSArray arrayWithObject:@&amp;quot;createdAt&amp;quot;]];
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方法3:使用Expression效率最高NSExpression＝＝》NSExpressionDescription＝》setPropertiesToFetch&lt;/p&gt;

&lt;h2 id=&#34;a-name-usingpersistentstores-8-a-6-using-persistent-stores&#34;&gt;&lt;a name=&#39;UsingPersistentStores-8&#39;&gt;&lt;/a&gt;6. Using Persistent Stores&lt;/h2&gt;

&lt;h5 id=&#34;6-1-创建一个store-nspersistentstore&#34;&gt;6.1 创建一个store:NSPersistentStore&lt;/h5&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//使用这个函数会创建一个NSPersistentStore代表了你的存储文件,一个隐含的操作是,如果存储文件不存在,就会先创建它
NSPersistentStoreCoordinator *psc = [moc persistentStoreCoordinator];
NSPersistentStore *roStore = [psc addPersistentStoreWithType:NSXMLStoreType
                                configuration:nil URL:url options:options error:&amp;amp;error];

//你不会直接使用NSPersistentStore;而是应该通过NSPersistentStoreCoordinator
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;6-2-changing-a-store-s-type-and-location&#34;&gt;6.2 Changing a Store’s Type and Location&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;NSPersistentStoreCoordinator *psc = [aManagedObjectContext
persistentStoreCoordinator];
NSURL *oldURL = &amp;lt;#URL identifying the location of the current store#&amp;gt;;
NSURL *newURL = &amp;lt;#URL identifying the location of the new store#&amp;gt;;
NSError *error = nil;
NSPersistentStore *xmlStore = [psc persistentStoreForURL:oldURL];
NSPersistentStore *sqLiteStore = [psc migratePersistentStore:xmlStore
									   toURL:newURL options:nil withType:NSSQLiteStoreType error:&amp;amp;error];									   									   
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;6-3-associate-metadata-with-a-store&#34;&gt;6.3 Associate Metadata With a Store&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;get： metadataForPersistentStore:/ metadataForPersistentStoreOfType:URL:error:.&lt;/li&gt;
&lt;li&gt;set: setMetadata:forPersistentStore:/setMetadata:forPersistentStoreOfType:URL:error:.&lt;/li&gt;
&lt;li&gt;use: 一个使用场景是migration=&amp;gt;使用系统自动创建的metadata就可以了isConfiguration:compatibleWithStoreMetadata;metadata不同(如版本)就会返回NO&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-name-howtopreloadandimportexistingdata-9-a-7-how-to-preload-and-import-existing-data&#34;&gt;&lt;a name=&#39;HowToPreloadandImportExistingData-9&#39;&gt;&lt;/a&gt;7.How To Preload and Import Existing Data&lt;/h2&gt;

&lt;p&gt;两种解决方案&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Fill in Core Data on startup from external source&lt;/code&gt;. For this the app can start up, notice that the database hasn’t been imported yet, and start reading in data from an external source (such as an SQLite database or XML file) and then start inserting the data into Core Data.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Provide pre-filled in SQLite database&lt;/code&gt;. For this we’ll let Core Data create the database structure for us based on the model, and then we populate the database with a utility app. The utility app could be a Mac or iPhone app that uses Core Data to populate the database via Core Data APIs, or some kind of program that fills in the SQLite database directly. Once the database is populated, just include it with the app and make the app use it as the default database if no database already exists. 就是代码里先生成sqlite文件,加入bundle,初始化的时候 copyItemAtURL 复制到本地目录.这是苹果文档官方推荐的方法,但是考虑到先创建数据库文件可能使得文件比较大,这个需要权衡.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;a-name-fetchedresultscontrolleruitableview-10-a-8-fetched-results-controller-uitableview&#34;&gt;&lt;a name=&#39;FetchedResultsControllerUITableView-10&#39;&gt;&lt;/a&gt;8.Fetched Results Controller&amp;lt;=&amp;gt;UITableView&lt;/h2&gt;

&lt;h5 id=&#34;8-1-简介&#34;&gt;8.1 简介&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;ee&lt;/li&gt;
&lt;li&gt;组成

&lt;ul&gt;
&lt;li&gt;A fetch request (NSFetchRequest instance):The one difference in this fetch request is that it must have at least one sort descriptor&lt;/li&gt;
&lt;li&gt;A managed object context&lt;/li&gt;
&lt;li&gt;A section name key path:用于coredata自动根据keypathname分割成几个section&lt;/li&gt;
&lt;li&gt;A cache name&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;a-name-class-3-a-三-深入-走上人生巅峰&#34;&gt;&lt;a name=&#39;class-3&#39;&gt;&lt;/a&gt;三.深入（走上人生巅峰）&lt;/h1&gt;

&lt;h2 id=&#34;a-name-migrations-11-a-1-migrations&#34;&gt;&lt;a name=&#39;Migrations-11&#39;&gt;&lt;/a&gt;1.Migrations&lt;/h2&gt;

&lt;h5 id=&#34;1-1-lightweight-migrations&#34;&gt;1.1 Lightweight Migrations&lt;/h5&gt;

&lt;p&gt;一类比较小的迁移,不需要创建mapping model;coredata会自动使用sql语句进行迁移，不需要load data或者转移整个store所以效率一般很高.(迁移之后iOS 5 keeps only the post-migration version)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//1.1
NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys:
				[NSNumber numberWithBool:YES], NSMigratePersistentStoresAutomaticallyOption, //tells the persistent store coordinator to automatically migrate the data.
				[NSNumber numberWithBool:YES], NSInferMappingModelAutomaticallyOption, nil];//tells the persistent store coordinator to infer 推断 the mapping model.
				
//对于1,2 设置 NSInferMappingModelAutomaticallyOption为NO!!!

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;


    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/200012.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    





    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/200013.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    





    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/200014.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    

&lt;/p&gt;

&lt;h5 id=&#34;1-2-migrate-with-mapping-model&#34;&gt;1.2 Migrate With Mapping Model&lt;/h5&gt;

&lt;p&gt;当改变不限于1.1所述的轻度迁移的时候，需要创建mappging model-》tell Core Data how to execute the migration&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NSAddEntityMappingType;NSRemoveEntityMappingType;NSCopyEntityMappingType lightweight migrations就可以处理&lt;/li&gt;
&lt;li&gt;NSTransformEntityMappingType可以用 value expression 来描述&lt;/li&gt;
&lt;li&gt;NSCustomEntityMappingType 则需要创建一个 NSEntityMigrationPolicy 的子类来描述;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;处理步骤



    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/200015.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    

&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//Core Data runs your migration in three stages.这个步骤细节可以由NSEntityMigrationPolicy来描述
1. It creates the objects in the destination model, including their attributes, based on the objects in the source model. ==&amp;gt;createDestinationInstancesForSourceInstance
2. It creates the relationships among the objects in the destination model.=&amp;gt;createRelationshipsForDestinationInstance
3. It validates the data in the destination model and saves it.=&amp;gt;performCustomValidationForEntityMapping

//2 example use expression: FUNCTION($manager, &amp;quot;destinationInstancesForEntityMappingNamed:sourceInstances:&amp;quot; , &amp;quot;CanvasToCanvas&amp;quot;, $source.canvases)
//caveat:createDestinationInstancesForSourceInstance的时候如果不super那么需要associateSourceInstance: withDestinationInstance: forEntityMapping: 
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;1-3-渐进式迁移-progressive-migrations-http-objccn-io-issue-4-7&#34;&gt;1.3 渐进式迁移 (Progressive Migrations)&lt;a href=&#34;http://objccn.io/issue-4-7/&#34;&gt;http://objccn.io/issue-4-7/&lt;/a&gt;&lt;/h5&gt;

&lt;h2 id=&#34;a-name-multiplecontext-12-a-2-multiple-context&#34;&gt;&lt;a name=&#39;Multiplecontext-12&#39;&gt;&lt;/a&gt;2. Multiple context&lt;/h2&gt;

&lt;h5 id=&#34;2-1-如何处理冲突&#34;&gt;2.1 如何处理冲突&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;Conflict Detection and Optimistic Locking:Optimistic Locking的原理When Core Data fetches an object from a persistent store, it takes a snapshot of its state,保存的时候要比较这个数据库里的对象和它的snapshot,如果不同说明这个对象在fetch之后被别人改过了=&amp;gt;Optimistic Locking(snapshot也会占用内存,它通过叫snapshot reference counting的机制管理)&lt;/li&gt;
&lt;li&gt;如何处理冲突由NSErrorMergePolicy(默认)/NSMergeByPropertyStoreTrumpMergePolicy/NSMergeByPropertyObjectTrumpMergePolicy/NSOverwriteMergePolicy指定&lt;/li&gt;
&lt;li&gt;Communicating Changes Between Contexts: NSManagedObjectContextDidSave&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;a-name-concurrencywithcoredata-13-a-3-concurrency-with-core-data&#34;&gt;&lt;a name=&#39;ConcurrencywithCoreData-13&#39;&gt;&lt;/a&gt;3. Concurrency with Core Data&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;For the most part, AppKit and UIKit are not thread safe; in particular, on OS X Cocoa bindings and controllers are not thread safe—if you are using these technologies, multi-threading may be complex.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;3-1-typically-recommended-approach&#34;&gt;3.1 typically-recommended approach&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Create a separate managed object context for each thread and share a single persistent store coordinator.不应该在不同thread传递Managed Object;如果要访问同一个entity,可以使用objectID或者构建同样的fetch;&lt;/li&gt;
&lt;li&gt;一般没有必要给Managed Object或者contexts lock(programming guide p137描述了需要lock the persistent store coordinator的情况)&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;3-2-track-changes-in-other-threads-using-notifications&#34;&gt;3.2 Track Changes in Other Threads Using Notifications&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;没错,Notifications..需要注意的是哪个线程post的Notifications那个线程才能收到,因此你需要在你save的contex所在的线程使用,比如使用performselector [mergeChangesFromContextDidSaveNotification] on Thread(你想通知的context所在的线程)&lt;/li&gt;
&lt;li&gt;你希望收到通知的线程注册NSManagedObjectContextDidSaveNotification;(再把他作为参数发给mergeChangesFromContextDidSaveNotification.这样 the context is able to safely merge the changes.);由于不同object和不同context关联,所以不改直接传递。可以传递objectid&lt;/li&gt;
&lt;li&gt;Fetch in the Background for UI Responsiveness;&lt;code&gt;fetch操作是经过内部优化的,如果需要coredata会自己新建线程来加快操作&lt;/code&gt;.但是如果还是需要在子线程fetch来防止UI阻塞,你可以新建background thread 以及对应的context,在其中fetch然后传递object ID;另一个线程通过object ID获取已经cache了object&lt;/li&gt;
&lt;li&gt;在后台线程保存:If you need to save on a background thread, you must write additional code such that the main thread prevents the application from quitting until all the save operation is complete.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;注意点
1.Use one NSPersistentStoreCoordinator per program. You don&#39;t need them per thread.
2.Create one NSManagedObjectContext per thread.
3.Never pass an NSManagedObject on a thread to the other thread.
4.Instead, get the object IDs via -objectID and pass it to the other thread.
More rules:

5.Make sure you save the object into the store before getting the object ID. Until saved, they&#39;re temporary, .and you can&#39;t access them from another thread.
6.And beware of the merge policies if you make changes to the managed objects from more than one thread.
7.NSManagedObjectContext&#39;s -mergeChangesFromContextDidSaveNotification: is helpful.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-coredataperformance-14-a-4-core-data-performance-提高效率的一些提示&#34;&gt;&lt;a name=&#39;CoreDataPerformance-14&#39;&gt;&lt;/a&gt;4.Core Data Performance 提高效率的一些提示&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Predicates的使用有技巧:一个例子 (salary &amp;gt; 5000000) AND (lastName LIKE &amp;lsquo;Quincey&amp;rsquo;) 比 (lastName LIKE &amp;lsquo;Quincey&amp;rsquo;) AND (salary &amp;gt; 5000000) 好；&lt;code&gt;巧用subquery能极大的提高fetch效率&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;fetchLimit:如果数据很多需要设置它,一次拉一部分数据;fetch某个需要的属性其他不要。&lt;/li&gt;
&lt;li&gt;不要fire 一个 fault的时候,不要fire&lt;/li&gt;
&lt;li&gt;Batch Faulting and Pre-fetching with the SQLite Store:有些情况下一个个的fire fault反而效率很低,这时候可以&lt;code&gt;batch fault&lt;/code&gt;（fetch request using a predicate with an IN operator或者use the NSFetchRequest method setReturnsObjectsAsFaults）&lt;code&gt;Pre-fetching&lt;/code&gt;（use the NSFetchRequest method setRelationshipKeyPathsForPrefetching）【p145】&lt;/li&gt;

&lt;li&gt;&lt;p&gt;节约内存&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;re-fault an individual managed object using NSManagedObjectContext’s refreshObject:mergeChanges: method&lt;/li&gt;
&lt;li&gt;create a fetch request you can set includesPropertyValues to NO 当你确定不需要使用这个property的时候&lt;/li&gt;
&lt;li&gt;reset method of NSManagedObjectContext to remove all managed objects associated with a context&lt;/li&gt;
&lt;li&gt;If you iterate over a lot of objects, you may need to use local autorelease pool block&lt;/li&gt;
&lt;li&gt;If you do not intend to use Core Data’s undo functionality, you can reduce your application&amp;rsquo;s resource requirements by setting the context’s undo manager to nil.&lt;/li&gt;
&lt;li&gt;break cycles by re-faulting objects (again by using the refreshObject:mergeChanges&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;使用instrument中的coredata工具&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;//不会fire fault的方法
isEqual:, hash, superclass, class, self, zone, isProxy, isKindOfClass:, isMemberOfClass:, conformsToProtocol:, respondsToSelector:, description, managedObjectContext, entity, objectID, isInserted, isUpdated, isDeleted, and isFault.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-multiplepersistentstorecustompersistentstore-15-a-5-multiple-persistent-store-custom-persistent-store&#34;&gt;&lt;a name=&#39;MultiplePersistentStoreCustomPersistentStore-15&#39;&gt;&lt;/a&gt;5.Multiple Persistent Store &amp;amp; Custom Persistent Store&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Multiple Persistent Store可以使用configuration进行配置,这样可以split data 到不同的data store;[persistentStoreCoordinator_ addPersistentStoreWithType:NSSQLiteStoreType configuration:@&amp;ldquo;Passwords&amp;rdquo; URL:passwordStoreURL options:nil error:&amp;amp;error]&lt;/li&gt;
&lt;li&gt;coredata允许创建custom的存储方式,但是这种方式只能是atomic store types（An atomic store is a store that writes its entire content all at once every time a save operation is executed）.比如可以创建类似CSV file的保存格式.&lt;/li&gt;
&lt;li&gt;需继承NSAtomicStore:在NSAtomicStore重载load和save等方法.比方说对于一个CSV文件,就是对文本的解析和保存,类似json的解析和序列化.而使用NSAtomicStore的好处是底层保存格式发生改变的时候上层代码不需要改变.&lt;/li&gt;
&lt;/ul&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/200016.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;h2 id=&#34;a-name-nspredicatensexpression-16-a-6-补充nspredicate和nsexpression入门&#34;&gt;&lt;a name=&#39;NSPredicateNSExpression-16&#39;&gt;&lt;/a&gt;6.补充NSPredicate和NSExpression入门&lt;/h2&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/200017.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;h5 id=&#34;6-1-nsexpression是nspredicate的内部实现方式&#34;&gt;6.1 NSExpression是NSPredicate的内部实现方式&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;NSPredicate是非常有用的，是Cocoa的优势之一。&lt;/code&gt;在&lt;code&gt;处理数据&lt;/code&gt;的时候要善于使用NSPredicate可以使代码清楚简介。(比如当你在filter一个array的时候不要再使用遍历了)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//用NSExpression实现
NSExpression *exprName = [NSExpression expressionForKeyPath:@&amp;quot;name&amp;quot;];
 NSExpression *exprJ = [NSExpression expressionForConstantValue:@&amp;quot;J&amp;quot;];
NSPredicate *p1 = [NSComparisonPredicate predicateWithLeftExpression:exprName rightExpression:exprJ modifier:NSDirectPredicateModifier type:NSBeginsWithPredicateOperatorType options:0];
NSExpression *exprAge = [NSExpression expressionForKeyPath:@&amp;quot;age&amp;quot;];
NSExpression *lower = [NSExpression expressionForConstantValue:[NSNumber numberWithInt:20]];
NSExpression *upper = [NSExpression expressionForConstantValue:[NSNumber numberWithInt:35]];
NSExpression *exprRange = [NSExpression expressionForAggregate:[NSArray arrayWithObjects:lower, upper, nil]];
NSPredicate *p2 = [NSComparisonPredicate predicateWithLeftExpression:exprAge rightExpression:exprRange modifier:NSDirectPredicateModifier type:NSBetweenPredicateOperatorType options:0];
NSPredicate *predicate = [NSCompoundPredicate andPredicateWithSubpredicates:[NSArray arrayWithObjects:p1, p2, nil]];

//改写成NSPredicate+query language
NSPredicate *predicate = [NSPredicate predicateWithFormat:@&amp;quot;name BEGINSWITH %@ AND age BETWEEN {%d, %d}&amp;quot;, @&amp;quot;J&amp;quot;, 20, 35];
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;6-2-nspredicate相关&#34;&gt;6.2 NSPredicate相关&lt;/h5&gt;

&lt;p&gt;


    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/200018.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    





    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/200019.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    





    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/200020.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    





    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/200021.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    





    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/200022.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    





    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/200023.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    





    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://u2takey.github.io/img/2015/02/200024.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    

&lt;/p&gt;

&lt;h4 id=&#34;a-name-17-a-参考&#34;&gt;&lt;a name=&#39;-17&#39;&gt;&lt;/a&gt;参考&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;注意:部分资料比较陈旧,请查看最新版&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/mapleyuan/p/3355615.html&#34;&gt;coredata 学习指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CoreData/cdProgrammingGuide.html&#34;&gt;Core Data Tutorial for iOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/samplecode/CoreDataUtility/Introduction/Intro.html&#34;&gt;Core Data Utility Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CoreData/cdProgrammingGuide.html&#34;&gt;Core Data Programming Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Predicates/predicates.html&#34;&gt;Predicate Programming Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/DataManagement/Conceptual/CoreDataSnippets/Introduction/Introduction.html&#34;&gt;Core Data Snippets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreDataVersioning/Articles/Introduction.html&#34;&gt;Core Data Model Versioning and Data Migration Programming Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/AtomicStore_Concepts/Introduction/Introduction.html&#34;&gt;Atomic Store Programming Topics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/Library/ios/documentation/DataManagement/Conceptual/IncrementalStorePG/Introduction/Introduction.html&#34;&gt;Incremental Store Programming Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.informit.com/articles/article.aspx?p=2160906&#34;&gt;Avoiding Ten Big Mistakes iOS Developers Make with Core Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/kesalin/article/details/6739319&#34;&gt;深入浅出 Cocoa 之 Core Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://objccn.io/&#34;&gt;objccn.io有8篇翻译的coredata介绍的文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://useyourloaf.com/blog/2012/01/19/core-data-queries-using-expressions.html&#34;&gt;Core Data Queries Using Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.raywenderlich.com/14742/core-data-on-ios-5-tutorial-how-to-work-with-relations-and-predicates&#34;&gt;How To Work with Relations and Predicates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.nsguy.com/blog/2014/02/09/learning-core-data/&#34;&gt;CoreData并发处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Pro Core Data for iOS【Data Access and Persistence Engine for iPhone, iPad, and iPod touch
Second Edition】&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nshipster.cn/nspredicate/&#34;&gt;NSPredicate&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;a-name-18-a-资源&#34;&gt;&lt;a name=&#39;-18&#39;&gt;&lt;/a&gt;资源&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://sourceforge.net/projects/sqlitebrowser/files/latest/download&#34;&gt;sqlitebrowser&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;a-name-19-a-更新&#34;&gt;&lt;a name=&#39;-19&#39;&gt;&lt;/a&gt;更新&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;2014-8-3第一版&lt;/li&gt;
&lt;li&gt;2014-8-11增加了来自Pro Core Data for iOS的内容&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>对技术的态度</title>
      <link>http://u2takey.github.io/blog/%E5%AF%B9%E6%8A%80%E6%9C%AF%E7%9A%84%E6%80%81%E5%BA%A6/</link>
      <pubDate>Sun, 14 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://u2takey.github.io/blog/%E5%AF%B9%E6%8A%80%E6%9C%AF%E7%9A%84%E6%80%81%E5%BA%A6/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;这是12年我写在新浪博客的文章，现在看起来觉得尴尬症都快犯了&amp;hellip;.我为什么会写这么奇怪的东西&amp;hellip;那时候我一定不太正常。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;知名的技术博客酷壳上有一篇文章，谈到对技术的态度，但大都是从技术角度谈技术，并没有真正谈到，面对日新月异的技术，一个人应该拥有的生活态度和哲学态度。&lt;/p&gt;

&lt;p&gt;相比之下，《禅与摩托车维修艺术》则给出了一些很具体的思考和答案，也解决了我的一些困惑。&lt;/p&gt;

&lt;p&gt;我出生在80年代，那时候技术革命开始在中国发生，在我的童年里经历了收音机，黑白电视机，彩色电视机，电脑等等变化，应接不暇。
和每个孩子一样，我起初对这些东西充满好奇，也对这些东西的神奇魔力无比困惑，我拆过随身听，电脑，电视机，当看到那些小小的元
件拼接在一起就可以实现那么多不可思议的事。可是后来我的态度却从好奇渐渐变成了麻木，以致厌恶。为什么会这样呢，这一点不难解释，
这件事也随时在发生。技术日新月异，各种革命性的东西不断出现，即使是一个精力充沛的智商超群的成年人一辈子也无法了解其中的千万
分之一，这些技术被人们使用，接受，然而却不在人们的控制，了解之中。这是一件令人苦恼的事。想象一下，一个人因为在使用电视机的时
候，却在苦恼于不能明白其实现原理，这时候他的好奇心对他来说反倒是一种折磨。这种情况逐渐发展，许多时候人们开始拒绝接受新技术，
他们习惯与那些了解的东西，认为那才是原始的。对于不断变化的时代，仿佛自己受到背叛，也因为无法控制而缺乏安全感。&lt;/p&gt;

&lt;p&gt;他们眼中世界的本来面目是自己了解的一面，技术的变化没有使人人兴奋，反倒使人疲惫，因为他感到即使了解了那些新的东西，他们也还是很快会被背叛。
这就是现实。尽管他们不曾放弃科技带来的好处，却时常宣称：原始的才是最好的，上帝的世界是几千年前的世界，他们甚至认为，对技术的贪婪会导致人类的灭亡。
这或许是一种反智主义在这个技术时代的体现。&lt;/p&gt;

&lt;p&gt;有这种思想的人随处可见，每天都可以见到拒绝服用医药，拒绝手术，拒绝使用电脑，手机，拒绝生物技术，拒绝基因产品和各种新科技的人们。
甚至，他们有时候在这个世界的力量强大得能够影响到许多技术的发展（尽管是暂时的）。&lt;/p&gt;

&lt;p&gt;可是。这是世界的本来面目，也是自我的本来面目。
技术与原始，并没有多少矛盾，这些矛盾只是理智的产物罢了。这里说的理智并不是我们在研究技术时所用的智力因素，
而是那种存在于这个世界，在人们心中，总试图分析这个世界，把这个世界分解成一个个矛盾体的分别心。从这点来说，
技术的使用和发展并不需要理智，技术只是工具，是人们的本性。技术的就是原始的，当人们第一次试图用石头制造一个工具的时候，技术就开始发展，他是人类的一部分。&lt;/p&gt;

&lt;h2 id=&#34;承认了这些-你才能树立好正确对待技术的态度-因为在这个时代-对待技术的态度-就是对待生活的态度&#34;&gt;承认了这些，你才能树立好正确对待技术的态度，因为在这个时代，对待技术的态度，就是对待生活的态度。&lt;/h2&gt;
</description>
    </item>
    
  </channel>
</rss>