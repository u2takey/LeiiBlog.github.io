<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>IOS &amp; MacOS on LeiiWang&#39;s Blog</title>
    <link>https://u2takey.github.io/categories/ios--macos/</link>
    <description>Recent content in IOS &amp; MacOS on LeiiWang&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 01 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://u2takey.github.io/categories/ios--macos/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Launchd Tutorial</title>
      <link>https://u2takey.github.io/blog/launchd/</link>
      <pubDate>Fri, 01 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://u2takey.github.io/blog/launchd/</guid>
      <description>

&lt;hr /&gt;

&lt;!-- vscode-markdown-toc --&gt;

&lt;ul&gt;
&lt;li&gt;1. &lt;a href=&#34;#LaunchdTutorial-0&#34;&gt; Launchd Tutorial&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;1.1. &lt;a href=&#34;#launchd-1&#34;&gt; 什么是launchd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.2. &lt;a href=&#34;#launchd-2&#34;&gt;为什么要launchd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.3. &lt;a href=&#34;#DaemonsandAgents-3&#34;&gt;Daemons and Agents&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.4. &lt;a href=&#34;#-4&#34;&gt;行为配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.5. &lt;a href=&#34;#-5&#34;&gt; 操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.6. &lt;a href=&#34;#recipes-6&#34;&gt;recipes（例子）&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;1.6.1. &lt;a href=&#34;#1app-7&#34;&gt;例1 app自动重启&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.6.2. &lt;a href=&#34;#2crontabstate-8&#34;&gt;例2 一个crontab任务（同时监控文件state）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.6.3. &lt;a href=&#34;#3inetd-9&#34;&gt;例3 一个inetd任务&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2. &lt;a href=&#34;#LaunchdSourcecode-10&#34;&gt; Launchd Sourcecode&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;2.1. &lt;a href=&#34;#-11&#34;&gt; 准备知识&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.2. &lt;a href=&#34;#launchctllist-12&#34;&gt; 命令launchctl list的运行流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.3. &lt;a href=&#34;#launchctlload-13&#34;&gt; 命令launchctl load的运行流程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3. &lt;a href=&#34;#-14&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /vscode-markdown-toc --&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;1-a-name-launchdtutorial-0-a-launchd-tutorial&#34;&gt;1. &lt;a name=&#39;LaunchdTutorial-0&#39;&gt;&lt;/a&gt; Launchd Tutorial&lt;/h2&gt;

&lt;h3 id=&#34;1-1-a-name-launchd-1-a-什么是launchd&#34;&gt;1.1. &lt;a name=&#39;launchd-1&#39;&gt;&lt;/a&gt; 什么是launchd&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;A unified, open-source service management framework for &lt;code&gt;starting, stopping and managing daemons, applications, processes, and scripts&lt;/code&gt;. Written and designed by Dave Zarzycki at Apple, it was introduced with Mac OS X Tiger and is licensed under the Apache License.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;1-2-a-name-launchd-2-a-为什么要launchd&#34;&gt;1.2. &lt;a name=&#39;launchd-2&#39;&gt;&lt;/a&gt;为什么要launchd&lt;/h3&gt;

&lt;p&gt;可以替代init，rc，init.d script，rc.d script，SystemStarter (OS X)，inetd / xinetd，crond / atd，watchdogd 而且使用更方便&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:footnote&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:footnote&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h3 id=&#34;1-3-a-name-daemonsandagents-3-a-daemons-and-agents&#34;&gt;1.3. &lt;a name=&#39;DaemonsandAgents-3&#39;&gt;&lt;/a&gt;Daemons and Agents&lt;/h3&gt;

&lt;p&gt;launchd 根据运行权限的不同,区分daemons(rootor the user specified with the key User)和agent(user)。&lt;/p&gt;

&lt;p&gt;不同的级别的daemon/agent存放位置也不同,其中/System/Library/为系统目录，不应该在此创建任何daemon/agent。第三方Library的目录在/Library/。而某个特别用户的目录在~/Library/&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Location&lt;/th&gt;
&lt;th&gt;Run on behalf of&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;User Agents&lt;/td&gt;
&lt;td&gt;~/Library/LaunchAgents&lt;/td&gt;
&lt;td&gt;Currently logged in user&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Global Agents&lt;/td&gt;
&lt;td&gt;/Library/LaunchAgents&lt;/td&gt;
&lt;td&gt;Currently logged in user&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Global Daemons&lt;/td&gt;
&lt;td&gt;/Library/LaunchDaemons&lt;/td&gt;
&lt;td&gt;root or the user specified with the key User&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;System Agents&lt;/td&gt;
&lt;td&gt;/System/Library/LaunchAgents&lt;/td&gt;
&lt;td&gt;Currently logged in user&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;System Daemons&lt;/td&gt;
&lt;td&gt;/System/Library/LaunchDaemons&lt;/td&gt;
&lt;td&gt;root or the user specified with the key User&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;1-4-a-name-4-a-行为配置&#34;&gt;1.4. &lt;a name=&#39;-4&#39;&gt;&lt;/a&gt;行为配置&lt;/h3&gt;

&lt;p&gt;daemon/agent的行为由一个property list定义。launchd提供了30多种配置项,full list请参考apple文档和 &lt;a href=&#34;http://launchd.info/&#34;&gt;http://launchd.info/&lt;/a&gt; ，这里简单介绍其中的几个。（可以用一个第三方工具LaunchControl配置）&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Key&lt;/th&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Label&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;job名字. 一般和plist名字相同,Required.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Program&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;执行程序路径. 如/Users/Me/Scripts/cleanup.sh.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ProgramArguments&lt;/td&gt;
&lt;td&gt;Array of strings&lt;/td&gt;
&lt;td&gt;Program 参数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;UserName&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;执行user名(defaults to root or current user)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RunAtLoad&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;td&gt;(defaults to NO) 标志任务是否要load进launchd立即启动&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;StartOnMount&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;td&gt;(defaults to NO)    标志任务是否要启动when a new filesystem is mounted.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;QueueDirectories&lt;/td&gt;
&lt;td&gt;Array of strings&lt;/td&gt;
&lt;td&gt;Watch a directory for new files&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;WatchPaths&lt;/td&gt;
&lt;td&gt;Array of strings&lt;/td&gt;
&lt;td&gt;Watch a filesystem path for changes. Can be a file or folder.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;StartInterval&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;Schedules job to run on a repeating schedule. Indicates number of seconds to wait between runs.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;StartCalendarInterval&lt;/td&gt;
&lt;td&gt;Dictionary of integers or Array of dictionaries of integers&lt;/td&gt;
&lt;td&gt;Job scheduling. The syntax is similar to cron.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;1-5-a-name-5-a-操作&#34;&gt;1.5. &lt;a name=&#39;-5&#39;&gt;&lt;/a&gt; 操作&lt;/h3&gt;

&lt;p&gt;所有行为都可以用一个命令行工具launchctl操作, 但使用LaunchControl更简单.下面列出了几个常见的操作。
####获取当前运行的所有demon/agent&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;host:~ user$ launchctl list 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####Loading a Job&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;launchctl load ~/Library/LaunchAgents/com.leiiwang.firsttest.plist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;com.leiiwang.firsttest.plist的内容:一个crontab任务，每分钟执行一次crontab-test.s，这个脚本只有一句话date.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;quot;&amp;gt;
&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
&amp;lt;dict&amp;gt;
        &amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;com.leiiwang.firsttest&amp;lt;/string&amp;gt;

        &amp;lt;key&amp;gt;ProgramArguments&amp;lt;/key&amp;gt;
        &amp;lt;array&amp;gt;
                &amp;lt;string&amp;gt;/Users/wangleo/bin/crontab-test.sh&amp;lt;/string&amp;gt;
        &amp;lt;/array&amp;gt;

        &amp;lt;key&amp;gt;KeepAlive&amp;lt;/key&amp;gt;
        &amp;lt;false/&amp;gt;

        &amp;lt;key&amp;gt;Nice&amp;lt;/key&amp;gt;
        &amp;lt;integer&amp;gt;1&amp;lt;/integer&amp;gt;

        &amp;lt;key&amp;gt;StartInterval&amp;lt;/key&amp;gt;
        &amp;lt;integer&amp;gt;60&amp;lt;/integer&amp;gt;

        &amp;lt;key&amp;gt;StandardErrorPath&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;/tmp/leiiwang.firsttest.err&amp;lt;/string&amp;gt;

        &amp;lt;key&amp;gt;StandardOutPath&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;/tmp/leiiwang.firsttest.out&amp;lt;/string&amp;gt;
&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出/tmp/leiiwang.firsttest.out&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Sat Dec 12 16:58:02 CST 2015
Sat Dec 12 16:59:02 CST 2015
Sat Dec 12 17:00:02 CST 2015
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####Unloading a Job&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;launchctl unload ~/Library/LaunchAgents/com.leiiwang.firsttest.plist
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-6-a-name-recipes-6-a-recipes-例子&#34;&gt;1.6. &lt;a name=&#39;recipes-6&#39;&gt;&lt;/a&gt;recipes（例子）&lt;/h3&gt;

&lt;h4 id=&#34;1-6-1-a-name-1app-7-a-例1-app自动重启&#34;&gt;1.6.1. &lt;a name=&#39;1app-7&#39;&gt;&lt;/a&gt;例1 app自动重启&lt;/h4&gt;

&lt;p&gt;这里用了macos 的open -W 命令.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;quot;&amp;gt;
&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
	&amp;lt;dict&amp;gt;
		&amp;lt;key&amp;gt;KeepAlive&amp;lt;/key&amp;gt;
		&amp;lt;true/&amp;gt;
		&amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt;
		&amp;lt;string&amp;gt;local.Safari.keepAlive&amp;lt;/string&amp;gt;
		&amp;lt;key&amp;gt;ProgramArguments&amp;lt;/key&amp;gt;
		&amp;lt;array&amp;gt;
			&amp;lt;string&amp;gt;/usr/bin/open&amp;lt;/string&amp;gt;
			&amp;lt;string&amp;gt;-W&amp;lt;/string&amp;gt;
			&amp;lt;string&amp;gt;/Applications/Safari.app&amp;lt;/string&amp;gt;
		&amp;lt;/array&amp;gt;
	&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-6-2-a-name-2crontabstate-8-a-例2-一个crontab任务-同时监控文件state&#34;&gt;1.6.2. &lt;a name=&#39;2crontabstate-8&#39;&gt;&lt;/a&gt;例2 一个crontab任务（同时监控文件state）&lt;/h4&gt;

&lt;p&gt;一个备份任务，在database运行的时候进行备份
使用PathState检测PID file是否存在确定任务特定任务database是否在执行
使用KeepAlive使得PID file存在时保持运行.
使用ThrottleInterval，任务终止后多久后重启&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;quot;&amp;gt;
&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
	&amp;lt;dict&amp;gt;
		&amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt;
		&amp;lt;string&amp;gt;com.example.app&amp;lt;/string&amp;gt;
		&amp;lt;key&amp;gt;Program&amp;lt;/key&amp;gt;
		&amp;lt;string&amp;gt;/Users/Me/Scripts/backup.sh&amp;lt;/string&amp;gt;
		&amp;lt;key&amp;gt;KeepAlive&amp;lt;/key&amp;gt;
		&amp;lt;dict&amp;gt;
			&amp;lt;key&amp;gt;PathState&amp;lt;/key&amp;gt;
			&amp;lt;dict&amp;gt;
				&amp;lt;key&amp;gt;/var/log/mysql.pid&amp;lt;/key&amp;gt;
				&amp;lt;true/&amp;gt;
			&amp;lt;/dict&amp;gt;
		&amp;lt;/dict&amp;gt;
		&amp;lt;key&amp;gt;ThrottleInterval&amp;lt;/key&amp;gt;
		&amp;lt;integer&amp;gt;3600&amp;lt;/integer&amp;gt;
	&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-6-3-a-name-3inetd-9-a-例3-一个inetd任务&#34;&gt;1.6.3. &lt;a name=&#39;3inetd-9&#39;&gt;&lt;/a&gt;例3 一个inetd任务&lt;/h4&gt;

&lt;p&gt;使用Sockets创建一个server监听13117&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
&amp;lt;dict&amp;gt;
  &amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;my.greeter&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;ProgramArguments&amp;lt;/key&amp;gt;
  &amp;lt;array&amp;gt;
    &amp;lt;string&amp;gt;/usr/bin/ruby&amp;lt;/string&amp;gt;
    &amp;lt;string&amp;gt;-e&amp;lt;/string&amp;gt;
    &amp;lt;string&amp;gt;puts &amp;quot;Hi #{gets.match(/(\w+)\W*\z/)[1]}, happy #{Time.now.strftime(&amp;quot;%A&amp;quot;)}!&amp;quot;&amp;lt;/string&amp;gt;
  &amp;lt;/array&amp;gt;
  &amp;lt;key&amp;gt;inetdCompatibility&amp;lt;/key&amp;gt;&amp;lt;dict&amp;gt;&amp;lt;key&amp;gt;Wait&amp;lt;/key&amp;gt;&amp;lt;false/&amp;gt;&amp;lt;/dict&amp;gt;
  &amp;lt;key&amp;gt;Sockets&amp;lt;/key&amp;gt;
  &amp;lt;dict&amp;gt;
    &amp;lt;key&amp;gt;Listeners&amp;lt;/key&amp;gt;
    &amp;lt;dict&amp;gt;
      &amp;lt;key&amp;gt;SockServiceName&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;13117&amp;lt;/string&amp;gt;
    &amp;lt;/dict&amp;gt;
  &amp;lt;/dict&amp;gt;
&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mac% launchctl load ~/Library/LaunchAgents/my.greeter.plist
mac% echo &amp;quot;My name is Leiiwang.&amp;quot; | nc localhost 13117
Hi Leiiwang, happy Saturday!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-a-name-launchdsourcecode-10-a-launchd-sourcecode&#34;&gt;2. &lt;a name=&#39;LaunchdSourcecode-10&#39;&gt;&lt;/a&gt; Launchd Sourcecode&lt;/h2&gt;

&lt;p&gt;整体感受是典型大公司代码，很多人修改的痕迹，各种bug修复和打补丁，搞得有点难看，但从整体上来看质量还算可以。&lt;/p&gt;

&lt;h3 id=&#34;2-1-a-name-11-a-准备知识&#34;&gt;2.1. &lt;a name=&#39;-11&#39;&gt;&lt;/a&gt; 准备知识&lt;/h3&gt;

&lt;p&gt;mach port: macos 的一种ipc类似一种消息队列和单向pipe的结合（macos在大部分版本中并不支持消息队列,大都时候mach port已经够好用了）,参见Ports, Port Rights, Port Sets, and Port Namespaces&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:footnote1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:footnote1&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;
kqueue: free bsd版本的epoll&lt;/p&gt;

&lt;h3 id=&#34;2-2-a-name-launchctllist-12-a-命令launchctl-list的运行流程&#34;&gt;2.2. &lt;a name=&#39;launchctllist-12&#39;&gt;&lt;/a&gt; 命令launchctl list的运行流程&lt;/h3&gt;

&lt;p&gt;launchctl是launchd提供的命令行工具,和其他类似的工具一样，launchctl作为一个server-client模式的client运行，client和server直接使用unix域套接字进行通信&lt;/p&gt;

&lt;p&gt;launchd中数据传输几乎只依赖一种数据结构_launch_data这种数据做array，dict,string&amp;hellip;作用,效率是很低的,但是也可以满足launchd的业务需求了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct _launch_data {
	uint64_t type;
	union {
		struct {
			union {
				launch_data_t *_array;
				char *string;
				void *opaque;
				int64_t __junk;
			};
			union {
				uint64_t _array_cnt;
				uint64_t string_len;
				uint64_t opaque_size;
			};
		};
		int64_t fd;
		uint64_t  mp;
		uint64_t err;
		int64_t number;
		uint64_t boolean;
		double float_num;
	};
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;client端流程
1. 在launchctl.c定义了各种的命令的对应运行函数,list的运行函数为list_cmd(..)
2. 构造一个msg，其key为LAUNCH_KEY_GETJOB
3. session相关
4. launchd_msg -&amp;gt; launchd_msg_internal -&amp;gt;launchd_msg_send:pack成一个launch_t结构
5. sendmsg通过socket发送命令结构体到server端
6. recvmsg通过socket读取返回&lt;/p&gt;

&lt;p&gt;server端流程
1. 在ipc.c创建了server并且通过kevent监听
2. kevent返回read事件,读取命令ipc_callback
3. launch_msg_recv
4. ipc_read_msg  -&amp;gt; ipc_read_msg2
5. core.c:job_export_all -&amp;gt;job_export_all2
6. 从rootmgr开始遍历，把所有job打包进一个dict并返回
7. launch_msg_send返回给客户端数据&lt;/p&gt;

&lt;h3 id=&#34;2-3-a-name-launchctlload-13-a-命令launchctl-load的运行流程&#34;&gt;2.3. &lt;a name=&#39;launchctlload-13&#39;&gt;&lt;/a&gt; 命令launchctl load的运行流程&lt;/h3&gt;

&lt;p&gt;这里我们特别的分析一种类似1.5 例子的简单任务的处理流程&lt;/p&gt;

&lt;p&gt;client端流程
1. 在launchctl.c定义了各种的命令的对应运行函数,load的运行函数为load_and_unload_cmd(..)
2. readfile：读取job配置的plist，检查几个必填key，读取到一个load_unload_state的结构体中
3. distill_job：对于watchpath/pathstate/queuedirectories任务特别处理，加入在watch job中
4. submit_job_pass,设置命令字为LAUNCH_KEY_SUBMIT_JOB
5. launchd_msg -&amp;gt; launchd_msg_internal -&amp;gt;launchd_msg_send:pack成一个launch_t结构
6. sendmsg通过socket发送命令结构体到server端
7. recvmsg通过socket读取返回&lt;/p&gt;

&lt;p&gt;server端流程
1. 前面步骤略
2. ipc_read_msg  -&amp;gt; ipc_read_msg2
3. core.c:job_import -&amp;gt;job_import_2 : 检查关键字,session相关&amp;hellip;
4. job_new:创建job,填充一个job_t结构,注意一些默认配置，设置callback
5. job_dispatch-&amp;gt;job_start 注意并不是所有的任务都会立即dispatch,start的,对于我们的这个任务同时根据配置加入了一个timer到kqueue，timer回调之后会再次dispatch-&amp;gt;start
6. job_start -&amp;gt; runtime_fork创建子进程,创建成功后父进程更新一些管理数据结构如actic_jobs等,并且把进程加入监听，监听进程的fork,exit等状态变化
7. 子进程运行startchild-&amp;gt;jobsetupattribute提取命令参数等，调用posix_spawn命令执行命令&lt;/p&gt;

&lt;h2 id=&#34;3-a-name-14-a-参考&#34;&gt;3. &lt;a name=&#39;-14&#39;&gt;&lt;/a&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://launchd.info/&#34;&gt;http://launchd.info/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://paul.annesley.cc/2012/09/mac-os-x-launchd-is-cool/&#34;&gt;http://paul.annesley.cc/2012/09/mac-os-x-launchd-is-cool/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Launchd&#34;&gt;https://en.wikipedia.org/wiki/Launchd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://alvinalexander.com/mac-os-x/launchd-examples-launchd-plist-file-examples-mac&#34;&gt;http://alvinalexander.com/mac-os-x/launchd-examples-launchd-plist-file-examples-mac&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:footnote&#34;&gt;The Ubuntu Linux distribution considered using launchd in 2006. launchd was rejected as an option because it was released under the Apple Public Source License
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:footnote&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:footnote1&#34;&gt;Ports, Port Rights, Port Sets, and Port NamespacesWith the exception of the task’s virtual address space, all other Mach resources are accessed through a level of indirection known as a port. A port is an endpoint of a unidirectional communication channel between a client who requests a service and a server who provides the service. If a reply is to be provided to such a service request, a second port must be used. This is comparable to a (unidirectional) pipe in UNIX parlance.In most cases, the resource that is accessed by the port (that is, named by it) is referred to as an object. Most objects named by a port have a single receiver and (potentially) multiple senders. That is, there is exactly one receive port, and at least one sending port, for a typical object such as a message queue.The service to be provided by an object is determined by the manager that receives the request sent to the object. It follows that the kernel is the receiver for ports associated with kernel-provided objects and that the receiver for ports associated with task-provided objects is the task providing those objects.For ports that name task-provided objects, it is possible to change the receiver of requests for that port to a different task, for example by passing the port to that task in a message. A single task may have multiple ports that refer to resources it supports. For that matter, any given entity can have multiple ports that represent it, each implying different sets of permissible operations. For example, many objects have a name port and a control port (sometimes called the privileged port). Access to the control port allows the object to be manipulated; access to the name port simply names the object so that you can obtain information about it or perform other non-privileged operations against it.Tasks have permissions to access ports in certain ways (send, receive, send-once); these are called port rights. A port can be accessed only via a right. Ports are often used to grant clients access to objects within Mach. Having the right to send to the object’s IPC port denotes the right to manipulate the object in prescribed ways. As such, port right ownership is the fundamental security mechanism within Mach. Having a right to an object is to have a capability to access or manipulate that object.Port rights can be copied and moved between tasks via IPC. Doing so, in effect, passes capabilities to some object or server.One type of object referred to by a port is a port set. As the name suggests, a port set is a set of port rights that can be treated as a single unit when receiving a message or event from any of the members of the set. Port sets permit one thread to wait on a number of message and event sources, for example in work loops.Traditionally in Mach, the communication channel denoted by a port was always a queue of messages. However, OS X supports additional types of communication channels, and these new types of IPC object are also represented by ports and port rights. See the section Interprocess Communication (IPC), for more details about messages and other IPC types.Ports and port rights do not have systemwide names that allow arbitrary ports or rights to be manipulated directly. Ports can be manipulated by a task only if the task has a port right in its port namespace. A port right is specified by a port name, an integer index into a 32-bit port namespace. Each task has associated with it a single port namespace.Tasks acquire port rights when another task explicitly inserts them into its namespace, when they receive rights in messages, by creating objects that return a right to the object, and via Mach calls for certain special ports (mach_thread_self, mach_task_self, and mach_reply_port.)
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:footnote1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>CoreData概要</title>
      <link>https://u2takey.github.io/blog/coredata/</link>
      <pubDate>Sun, 01 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>https://u2takey.github.io/blog/coredata/</guid>
      <description>

&lt;h1 id=&#34;注&#34;&gt;注&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;本文是学习中觉得比较重要的知识点的摘录,需要系统的学习请查看manual,需要速成教程本文的参考部分提供的几篇不错的文章。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;!-- vscode-markdown-toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#class-0&#34;&gt;一.入门&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#class-1&#34;&gt;1. 几个重要的概念/class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#DatamodelManagedObjects-1&#34;&gt;2. 定义数据:Data model＝》Managed Objects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#fetchManagedObjects.-2&#34;&gt;3.操作数据:添加、fetch、删除Managed Objects.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#class-2&#34;&gt;二.理解&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ManagedObjectModel-3&#34;&gt;1.理解 Managed Object Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ManagedObject-4&#34;&gt;2.理解 Managed Object&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ManagedObject2.3-5&#34;&gt;3.操作 Managed Object（2.3续）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Object:-6&#34;&gt;4.Object内存管理:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#RelationshipAndfetchproperties-7&#34;&gt;5.Relationship And fetch properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#UsingPersistentStores-8&#34;&gt;6. Using Persistent Stores&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#HowToPreloadandImportExistingData-9&#34;&gt;7.How To Preload and Import Existing Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#FetchedResultsControllerUITableView-10&#34;&gt;8.Fetched Results Controller&amp;lt;=&amp;gt;UITableView&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#class-3&#34;&gt;三.深入（走上人生巅峰）&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#Migrations-11&#34;&gt;1.Migrations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Multiplecontext-12&#34;&gt;2. Multiple context&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ConcurrencywithCoreData-13&#34;&gt;3. Concurrency with Core Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#CoreDataPerformance-14&#34;&gt;4.Core Data Performance 提高效率的一些提示&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#MultiplePersistentStoreCustomPersistentStore-15&#34;&gt;5.Multiple Persistent Store &amp;amp; Custom Persistent Store&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#NSPredicateNSExpression-16&#34;&gt;6.补充NSPredicate和NSExpression入门&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#-17&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#-18&#34;&gt;资源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#-19&#34;&gt;更新&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /vscode-markdown-toc --&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;a-name-class-0-a-一-入门-升职加薪&#34;&gt;&lt;a name=&#39;class-0&#39;&gt;&lt;/a&gt;一.入门（升职加薪）&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;coreData实现什么样的目的:类似archiving实现对象的保存和恢复&lt;/li&gt;
&lt;li&gt;coreData相比archiving等有什么样的优势:

&lt;ul&gt;
&lt;li&gt;managing changes of your model objects==&amp;gt;支持redo undo;支持对象之间的关系管理.&lt;/li&gt;
&lt;li&gt;节约内存,取一部分对象subset&lt;/li&gt;
&lt;li&gt;gui-based editor / setting of default values and attribute value validation&lt;/li&gt;
&lt;li&gt;disjoint sets of edits of your objects.-&amp;gt;不save 改变就是discard&lt;/li&gt;
&lt;li&gt;easy upgrade/migration.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;和&lt;code&gt;直接使用&lt;/code&gt;sqlite的不同

&lt;ul&gt;
&lt;li&gt;No primary keys means no foreign keys, either; Core Data manages the relationships between entities, or tables, and performs any necessary joins for you.&lt;/li&gt;
&lt;li&gt;core data本身不是ORM,是object graph management framework，它可以选择sqlite，xml，plist或是其他方式作为持久化方案;不能读取任意的sqlite文件&lt;/li&gt;
&lt;li&gt;方便支持undo,redo&lt;/li&gt;
&lt;li&gt;你只需要worry about data,而不是data storage mechanisms.(举个例子many to many的关系会导致core data自动创建一个关系表,如果直接使用sqlte你需要自己考虑并创建)
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;!!!注意:尽管不需要考虑存储机制,但是data model的设计还是需要深思熟虑的.Relational Database Normalization的规则在设计datamodel的时候同样需要被考虑。&lt;a href=&#34;http://support.microsoft.com/kb/283878/zh-cn&#34;&gt;一个简单的数据库标准化的参考&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;a-name-class-1-a-1-几个重要的概念-class&#34;&gt;&lt;a name=&#39;class-1&#39;&gt;&lt;/a&gt;1. 几个重要的概念/class&lt;/h2&gt;

&lt;h5 id=&#34;1-1-managed-object-model&#34;&gt;1.1 Managed Object Model:&lt;/h5&gt;

&lt;p&gt;You can think of this as the &lt;code&gt;database schema&lt;/code&gt;. It is a class that contains definitions for each of the objects (also called “Entities”) that you are storing in the database是描述应用程序的数据模型，这个模型包含实体（Entity），特性（Property），读取请求（Fetch Request）等. Usually, you will use the visual editor you just peeked at to set up what objects are in the database, what their attributes, and how they relate to each other. However, you can do this with code too!&lt;/p&gt;

&lt;h5 id=&#34;1-2-persistent-store-coordinator&#34;&gt;1.2 Persistent Store Coordinator:&lt;/h5&gt;

&lt;p&gt;You can think of this as the &lt;code&gt;database connection&lt;/code&gt;. Here’s where you set up the actual names and locations of what databases will be used to store the objects, and any time a managed object context needs to save something it goes through this single coordinator,处理底层的对数据文件的读取与写入。一般我们无需与它打交道.&lt;/p&gt;

&lt;h5 id=&#34;1-3-managed-object-context&#34;&gt;1.3 Managed Object Context:&lt;/h5&gt;

&lt;p&gt;You can think of this as a &lt;code&gt;“scratch pad”&lt;/code&gt;(object space) for objects that come from the database. It’s also the most important of the three for us, because we’ll be working with this the most. Basically, whenever you need to get objects, insert objects, or delete objects, you call methods on the managed object context (or at least most of the time!);Managed Object Context是Managed Object和其他CoreData模块的桥梁因此你应该总希望keep reference to it.&lt;/p&gt;

&lt;h5 id=&#34;1-4-managed-object&#34;&gt;1.4 Managed Object&lt;/h5&gt;

&lt;p&gt;代表一个Entity的类;&lt;/p&gt;

&lt;h5 id=&#34;1-5-entity-description&#34;&gt;1.5 Entity Description&lt;/h5&gt;

&lt;p&gt;注意理解这样的概念Entity是数据,但是它同时又是一个抽象的概念,他必须有实体的类来描述和代表他.一个Entity Description就是用来描述这个Entity的,描述的目的可能是为了对Entity进行fetch等相关操作等;而Entity取出来了之后又需要一个实体类来代表它,这个类就是一个managed object类.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//Managed Object Model--包含-》Entity Description&amp;lt;---Entity---&amp;gt;managed object;
//见图1.2,1.3.managed object和Entity Description

//你可以从datamodel获取Entity Description
NSEntityDescription *employeeEntity = [[managedObjectModel entitiesByName] objectForKey:@&amp;quot;Employee&amp;quot;];

//也可以从context直接获取
NSEntityDescription *employeeEntity = [NSEntityDescription entityForName:@&amp;quot;Employee&amp;quot; inManagedObjectContext:context];

// Entity Description 和managed object是彼此关联的 可以通过Entity Description得到managed object
// 也可以
&lt;/code&gt;&lt;/pre&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/24752_1314847532b1OE.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;Figure 1-1  A simple Core Data stack—1&lt;/p&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/2000.jpg&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;Figure 1-2  A simple Core Data stack-2&lt;/p&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/20001.jpg&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;Figure 1-3  Managed objects in a context, and a table in the persistent store&lt;/p&gt;

&lt;h2 id=&#34;a-name-datamodelmanagedobjects-1-a-2-定义数据-data-model-managed-objects&#34;&gt;&lt;a name=&#39;DatamodelManagedObjects-1&#39;&gt;&lt;/a&gt;2. 定义数据:Data model＝》Managed Objects&lt;/h2&gt;

&lt;h5 id=&#34;2-1-subclass-of-nsmanagedobject-可以看成是数据表的一个record-a-record-in-a-table-in-a-database&#34;&gt;2.1. (Subclass of)NSManagedObject 可以看成是数据表的一个record。a record in a table in a database.&lt;/h5&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/20002.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;h5 id=&#34;2-2-nsmanagedobjectmodel和-nsmanagedobject的关系-model是描述数据模型的schema-是一组entity-description-objects-instances-of-nsentitydescription-的集合-一个entity-description描述一个entity-a-table-in-a-database&#34;&gt;2.2. NSManagedObjectModel和 NSManagedObject的关系:model是描述数据模型的schema,是一组entity description objects (instances of NSEntityDescription)的集合; 一个entity description描述一个entity (a table in a database).&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;当datamodel变化的时候core data不能读取数据-&amp;gt;类似的存储方式都有类似问题,coredata提供了管理这种变化的方法&amp;ndash;&lt;a href=&#34;http://genekc07.stowers.org/Users/mec/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.AppleiOS5_1.iOSLibrary.docset/Contents/Resources/Documents/documentation/Cocoa/Conceptual/CoreDataVersioning/Articles/Introduction.html#//apple_ref/doc/uid/TP40004399&#34;&gt;Core Data Model Versioning and Data Migration Programming Guide&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/20003.jpg&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;Figure 2-1 illustrates the relationship between an entity description in a model, a table in the database, and a managed object corresponding to a single record in the table.&lt;/p&gt;

&lt;h5 id=&#34;2-3-with-core-data-you-cannot-retrieve-only-certain-attributes-of-an-object-you-have-to-retrieve-the-entire-object-也就是说不能像数据库一样只拿出一项中的部分列出来-如果要实现这样的功能需要-factor-the-objects-into-serverral-pieces-把对象分成几部分&#34;&gt;2.3. With Core data you cannot retrieve only certain attributes of an object – you have to retrieve the entire object. 也就是说不能像数据库一样只拿出一项中的部分列出来,如果要实现这样的功能需要 factor the objects into serverral pieces 把对象分成几部分.&lt;/h5&gt;

&lt;h5 id=&#34;2-4-auto-generating-model-files-自动生成数据object的oc文件-也可以不使用-用setvalueforkey解决&#34;&gt;2.4. Auto Generating Model Files:自动生成数据object的oc文件(也可以不使用 用setvalueforkey解决)&lt;/h5&gt;

&lt;p&gt;使用自动生成的subclass of NSManagedObject有什么好处:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Better support from the development tools.(You get code completion for property accessor methods, and compile-time type- and symbol-checking;这就是为什么在自动生成的class里头属性都声明为dynamic,coredate自动runtime生成accessor;同时也没有delloc因为生命周期由coredata管理&amp;ndash;自己新建要自己管理)&lt;/li&gt;
&lt;li&gt;Support for custom methods for the entity.(In many situations, you want to provide special logic for the entity, such as validation methods or derived properties)&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;生成完成之后你会发现datamodel里的entity class也被自动更新了.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;2-5-managed-objects-entity-的一些属性&#34;&gt;2.5.Managed Objects / Entity 的一些属性&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;NSEntityDescription:是一个Entity的描述,而Entity是一个抽象的概念,并没有Entity这样一个类,Entity代表了&lt;code&gt;数据&lt;/code&gt;,可以继承Entity,使用abstract entity;Entity是与NSManagedObject这个&lt;code&gt;class&lt;/code&gt;对应的(但是并不完全等同),一个Entity由NSManagedObject代表;而一个Entity的&lt;code&gt;instance&lt;/code&gt;由一个NSManagedObject的实例代表,实际理解中可以把Entity等同于代表其的NSManagedObject class。Abstract Entities - you will not create any instances of that entity.&lt;/li&gt;
&lt;li&gt;NSEntityDescription 有属性 NSAttributeDescription 和 NSRelationshipDescription,NSFetchedPropertyDescription 用于描述Entity在schema中的特点.&lt;/li&gt;
&lt;li&gt;Properties:对象的属性,包括Attribute,Relationship,Fetched Property&lt;/li&gt;
&lt;li&gt;Attribute可以是transient说明实际不会被保存,一般是runtime的时候生成的.Index/optional类似数据库中的概念类似.可以设置类型和validation。但是不建议设置optinal,尤其是数值类型的,尽量不设置optinal并设置default value因为数据库中的NULL不同于0或者@&amp;ldquo;&amp;rdquo; (数据库中的NULL取出来对应nil并没有问题,predicate也可以设置nil,但是nil = 0这样会造成混淆&amp;ndash;nil=NULL=Nil=0,[NSNull null]!=0);另:保存为transformable是用二进制/nsdata/BLOB来保存数据,通常来说不是一个好的选择,和binary data类型区别仅仅是多了一个转换过程(比如nscolor可以转成字符串或16进制数而不是nsdata,二进制不易于查询)&lt;/li&gt;
&lt;li&gt;fetch property:Relationship 在对象中变成对应关系的指针,使用时load对应的数据.Fetched properties represent weak, one-way relationships.&lt;/li&gt;
&lt;li&gt;Fetch Request Templates:是常用的Fetch Request,用的时候从datamodel获取即可直接使用 managedObjectModel.fetchRequestTemplatesByName[@&amp;ldquo;FetchRequestName&amp;rdquo;]&lt;/li&gt;
&lt;li&gt;User Info Dictionaries:和datamode绑定的其他任意信息.&lt;/li&gt;
&lt;li&gt;Configurations:一般用于多个数据store（详解见第二部分）。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Managed Object Model 抽象&lt;/th&gt;
&lt;th&gt;NSManagedObjectModel&lt;/th&gt;
&lt;th&gt;数据模型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Entity&lt;/td&gt;
&lt;td&gt;NSEntityDescription&lt;/td&gt;
&lt;td&gt;抽象数据类型，相当于数据库中的表&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Property&lt;/td&gt;
&lt;td&gt;NSPropertyDescription Entity&lt;/td&gt;
&lt;td&gt;特性，相当于数据库表中的一列&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;gt; Attribute&lt;/td&gt;
&lt;td&gt;NSAttributeDescription&lt;/td&gt;
&lt;td&gt;基本数值型属性（如Int16,BOOL,Date等类型的属性）非标准Transformable&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;gt; Relationship&lt;/td&gt;
&lt;td&gt;NSRelationshipDescription&lt;/td&gt;
&lt;td&gt;属性之间的关系&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;gt; Fetched Property&lt;/td&gt;
&lt;td&gt;NSFetchedPropertyDescription&lt;/td&gt;
&lt;td&gt;查询属性（类似一种单向关系，易用查询）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/20004.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    






    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/20005.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;Figure 2-2  Entity description with two attributes and a relationship&lt;/p&gt;

&lt;h2 id=&#34;a-name-fetchmanagedobjects-2-a-3-操作数据-添加-fetch-删除managed-objects&#34;&gt;&lt;a name=&#39;fetchManagedObjects.-2&#39;&gt;&lt;/a&gt;3.操作数据:添加、fetch、删除Managed Objects.&lt;/h2&gt;

&lt;h5 id=&#34;3-1-添加-insertnewobjectforentityforname-inmanagedobjectcontext-获得对应的managedobject-修改属性-save&#34;&gt;3.1 添加:insertNewObjectForEntityForName:inManagedObjectContext: 获得对应的ManagedObject-》修改属性 (-》save)&lt;/h5&gt;

&lt;h5 id=&#34;3-2-fetch-需要一个fetch-request-设置其nsentitydescription-predicate-sort-descriptor-类似一个select语句-open-the-scheme-drop-down-in-xcode-and-select-edit-scheme-select-the-run-scheme-and-select-the-arguments-tab-add-the-following-argument-com-apple-coredata-sqldebug-1-这样可以让你看到原始的select语句&#34;&gt;3.2 Fetch:需要一个fetch request,设置其NSEntityDescription,predicate,sort descriptor＝》类似一个select语句(Open the Scheme drop-down in Xcode and select ‘Edit Scheme…’. Select the ‘Run’ scheme and select the ‘Arguments’ tab. Add the following argument: “-com.apple.CoreData.SQLDebug 1”.这样可以让你看到原始的select语句)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;NSFetchedResultsController用于为tableviewfetch数据,经过了优化可以节约大量代码以及保证效率和内存上的优化.&lt;/li&gt;
&lt;li&gt;You cannot fetch using a predicate based on transient properties&lt;/li&gt;
&lt;li&gt;可以fetch特定的object用来检查是不是被删掉了 感觉使用场景不是很高[NSPredicate predicateWithFormat:@&amp;ldquo;self == %@&amp;rdquo;, targetObject];也可以使用@&amp;ldquo;self IN %@&amp;rdquo;,arrayOfManagedObjectIDs&lt;/li&gt;
&lt;li&gt;如果要fetch一个特定的比如value是最大值的可以使用 NSExpression(详见programing guide)&lt;/li&gt;
&lt;li&gt;fetch 设置成 super-entity 的时候会得到满足要求的所有sub-entities和super-entity(如果不是abstract的)&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;3-3-删除-managedobjectcontext-deleteobject-save-删除的时候需要考虑relationship不同的relationship删除策略不一样&#34;&gt;3.3 删除: managedObjectContext deleteObject: (-》save)(删除的时候需要考虑relationship不同的relationship删除策略不一样)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;删除会发送 NSManagedObjectContextObjectsDidChangeNotification&lt;/li&gt;
&lt;/ul&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/20006.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;h5 id=&#34;3-4-操作关系属性-得到关系属性的时候获得的是一个fault-object&#34;&gt;3.4 操作关系属性:得到关系属性的时候获得的是一个fault object&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;一对一关系:&lt;/li&gt;
&lt;li&gt;一(多)对多关系:&lt;/li&gt;
&lt;li&gt;一个隐含的知识点:当你取得一个关系的object的时候没有必要设置一个fetch,会自动帮你取得(开始是个fault)
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;// 使用KVC
NSMutableSet *employees = [aDepartment mutableSetValueForKey:@&amp;quot;employees&amp;quot;];
[employees addObject:newEmployee];
[employees removeObject:firedEmployee];


// or 使用自动生成的关系操作方法
[aDepartment addEmployeesObject:newEmployee];
[aDepartment removeEmployeesObject:firedEmployee];

//1.是.employees返回的是set 和 mutableSetValueForKey 返回的有所不同 操作这个set
// KVO change notifications are not emitted and the inverse relationship is not updated correctly.
[aDepartment.employees addObject:newEmployee]; // do not do this!
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;值得注意的是:无论是添加 还是 删除 对managedObjectContext 操作的同时还需要对你用于缓存的datasource进行同样的操作.managedObjectContext 会缓存object 必要的时候 可以 managedObjectContext refreshObject:mergeChanges/reset可以清空缓存以节约内存,同时可用[[context registeredObjects] count]查看.&lt;/p&gt;
&lt;/blockquote&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/20007.gif&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;Figure 3-1 fetch request 示意&lt;/p&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/20008.jpg&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;Figure 3-2 fetch 流程&lt;/p&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/20009.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;h1 id=&#34;a-name-class-2-a-二-理解-迎娶白富美&#34;&gt;&lt;a name=&#39;class-2&#39;&gt;&lt;/a&gt;二.理解（迎娶白富美）&lt;/h1&gt;

&lt;h2 id=&#34;a-name-managedobjectmodel-3-a-1-理解-managed-object-model&#34;&gt;&lt;a name=&#39;ManagedObjectModel-3&#39;&gt;&lt;/a&gt;1.理解 Managed Object Model&lt;/h2&gt;

&lt;h5 id=&#34;1-1-创建managed-object-model-可以使用xib或者完全使用code&#34;&gt;1.1 创建Managed Object Model:可以使用xib或者完全使用code&lt;/h5&gt;

&lt;h5 id=&#34;1-2-compiling-model-xcdatamodeld是-deployment-resource-经过特殊的编译器-momc-编译-成为-mom文件-momd是文件夹&#34;&gt;1.2 Compiling Model:xcdatamodeld是 deployment resource 经过特殊的编译器 momc 编译 成为 mom文件(momd是文件夹)&lt;/h5&gt;

&lt;h5 id=&#34;1-3-loading-model-两种方法initwithcontentsofurl-指定url-preferred-mergedmodelfrombundles-如果不需要分开model的时候&#34;&gt;1.3 Loading Model:两种方法initWithContentsOfURL (指定url,preferred)/ mergedModelFromBundles (如果不需要分开model的时候)&lt;/h5&gt;

&lt;h5 id=&#34;1-4-change-model-如果还需要访问existing-stores中的数据就不能直接修改model-而是应该-have-a-versioned-model-修改时创建一个新的version-model旧的不动&#34;&gt;1.4 Change Model:如果还需要访问existing stores中的数据就不能直接修改Model，而是应该 have a versioned model;修改时创建一个新的version model旧的不动&lt;/h5&gt;

&lt;h5 id=&#34;1-5-localizing-model-providing-localizationdictionary&#34;&gt;1.5 Localizing Model:providing localizationDictionary&lt;/h5&gt;

&lt;p&gt;


    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/200010.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    





    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/200011.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    

&lt;/p&gt;

&lt;h2 id=&#34;a-name-managedobject-4-a-2-理解-managed-object&#34;&gt;&lt;a name=&#39;ManagedObject-4&#39;&gt;&lt;/a&gt;2.理解 Managed Object&lt;/h2&gt;

&lt;h5 id=&#34;2-1-概念-managed-object是nsmanagedobject的instance-associated-with-an-entity-description-an-instance-of-nsentitydescription-associated-with-a-managed-object-context-record-和-object是一对多的关系-因为可能有几个context等情况-几个object可能对应的是同一个数据&#34;&gt;2.1 概念:Managed Object是NSManagedObject的instance / associated with an entity description (an instance of NSEntityDescription)/ associated with a managed object context /record 和 object是一对多的关系,因为可能有几个context等情况,几个object可能对应的是同一个数据&lt;/h5&gt;

&lt;h5 id=&#34;2-2-object-accessor&#34;&gt;2.2 Object Accessor:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;自动生成Accessor(注:如果你自己写Accessor, dynamically-generated method snever replace your own code.);&lt;/li&gt;
&lt;li&gt;基于KVO;&lt;/li&gt;
&lt;li&gt;没有执行NSCopying协议&lt;/li&gt;
&lt;li&gt;weak会被当成strong,只能用strong和copy&lt;/li&gt;
&lt;li&gt;To Many Relation会变成NSSet;同样自动生成catgory方法;&lt;/li&gt;
&lt;li&gt;dynamic的方法子类不能super&lt;/li&gt;
&lt;li&gt;如果要自定义accessor方法需要符合特定的规则:按照顺序调用&lt;code&gt;relevant access and KVO change notification methods&lt;/code&gt;(Important: You are strongly encouraged to use dynamic properties)见下面的代码示例.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;2-3-managed-object-和其他对象有三点主要不同&#34;&gt;2.3 Managed Object 和其他对象有三点主要不同:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;instance of (subclass of) NSManagedObject&lt;/li&gt;
&lt;li&gt;Exists in an environment defined by its &lt;code&gt;managed object context&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Has an associated &lt;code&gt;entity description&lt;/code&gt; that describes the properties of the object&lt;/li&gt;
&lt;li&gt;(核心元素是一个context一个entity description)&lt;/li&gt;
&lt;li&gt;(创建不用alloc;初始化不重载init见3.1)
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt; @interface Department (PrimitiveAccessors)
  - (NSString *)primitiveName;
  - (void)setPrimitiveName:(NSString *)newName;
  @end

 
- (NSString *)name
{
      [self willAccessValueForKey:@&amp;quot;name&amp;quot;];
      NSString *myName = [self primitiveName];
      [self didAccessValueForKey:@&amp;quot;name&amp;quot;];
      return myName;
}
- (void)setName:(NSString *)newName
{
      [self willChangeValueForKey:@&amp;quot;name&amp;quot;];
      [self setPrimitiveName:newName];
      [self didChangeValueForKey:@&amp;quot;name&amp;quot;];
}


//类似的当你想实现一个scalar type (NSInteger or CGFloat), or one supported by NSKeyValueCoding (NSRect, NSPoint, NSSize, NSRange),

@property CGFloat radius;

- (CGFloat)radius
  {
      [self willAccessValueForKey:@&amp;quot;radius&amp;quot;];
      float f = _radius;//数据库取出存在_radius =&amp;gt; 转换成 float
      [self didAccessValueForKey:@&amp;quot;radius&amp;quot;];
      return f;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-managedobject2-3-5-a-3-操作-managed-object-2-3续&#34;&gt;&lt;a name=&#39;ManagedObject2.3-5&#39;&gt;&lt;/a&gt;3.操作 Managed Object（2.3续）&lt;/h2&gt;

&lt;h5 id=&#34;3-1-managed-object-ids-and-uris&#34;&gt;3.1 Managed Object IDs and URIs&lt;/h5&gt;

&lt;p&gt;A managed object ID uniquely identifies the same managed object both between managed object contexts in a single application, and in multiple applications (as in distributed systems);创建的时候是temporary的可以用isTemporaryID测试.类似表里的primary key但是范围更大.可以转换成url的形式URIRepresentation通过他们可以直接获取对应的object;甚至可以在不同的store里传递&lt;/p&gt;

&lt;h5 id=&#34;3-2-validation&#34;&gt;3.2 Validation&lt;/h5&gt;

&lt;p&gt;需要指出的是，&lt;code&gt;KVC是不会自动调用键值验证方法的&lt;/code&gt;，就是说我们需要手动验证。&lt;code&gt;但是有些技术，比如CoreData会自动调用&lt;/code&gt;。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Property-Level Validation：下面的第一个方法&lt;/li&gt;
&lt;li&gt;Inter-Property validation: 下面的第2-4个方法;提供了更多validation;和Property-Level Validation不同的是,validation的关注点在于不同的combination是不是符合要求;注意要类似[super validateForInsert:error]先运行父类的方法to ensure that individual property validation methods are also invoked&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;//如下的4个方法在Managed Object的生命周期会自动触发 
// validateValue 会自动调用- (BOOL)validate&amp;lt;Key&amp;gt;:error: (可以重载他而不要直接重载validateValue)
- (BOOL)validateValue:(id *)value forKey:(NSString *)key error:(NSError **)error;    // KVC

// 下面三个是Inter-Property validation 提供了更多的validate的机会
- (BOOL)validateForDelete:(NSError **)error;
- (BOOL)validateForInsert:(NSError **)error;
- (BOOL)validateForUpdate:(NSError **)error;
// 要注意的一个问题是:对于error的处理,error可能是已经存在的,这时候需要添加error信息而不是重新赋值
//be sure to combine errors and not overwrite them
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;3-3-faults&#34;&gt;3.3 Faults&lt;/h5&gt;

&lt;p&gt;In some situations a managed object may be a “fault”—an object whose property values have not yet been loaded from the external store. When you access persistent property values, a fault “fires” and its persistent data is retrieved automatically from the store.可以手动把一个方法变成fault:NSManagedObjectContext&amp;rsquo;s refreshObject:mergeChanges:.比方说object的一个关系属性在没使用的时候就是一个fault。&lt;/p&gt;

&lt;h5 id=&#34;3-4-ensuring-data-is-up-to-date&#34;&gt;3.4 Ensuring Data Is Up-to-Date&lt;/h5&gt;

&lt;p&gt;refreshObject:mergeChanges:根据mergeChanges的flag操作是merge还是变成fault;注意transient的属性刷新之后会变成pre-refresh value after awakeFromFetch is invoked；为了保证transient的属性是最新的可以设置**IsValiddid属性并在TurnIntoFault方法里写成NO&lt;/p&gt;

&lt;h5 id=&#34;3-5-不同context-copy-and-paste&#34;&gt;3.5 不同context copy and paste&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;NSManagedObjectID *objectID = [managedObject objectID];
NSManagedObject *copy = [context2 objectWithID:objectID];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-object-6-a-4-object内存管理&#34;&gt;&lt;a name=&#39;Object:-6&#39;&gt;&lt;/a&gt;4.Object内存管理:&lt;/h2&gt;

&lt;h5 id=&#34;4-1-managed-object和context&#34;&gt;4.1 Managed Object和Context&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;两者是关联的,但是关系是weak的。不过context在其中的Managed Object的pending transaction/reset/rollback之前是有strong reference的(undomanager在之后都有strong reference);&lt;/li&gt;
&lt;li&gt;设置setRetainsRegisteredObjects可以是使得Managed Object依赖与context(但是一般不会这么做,因为你自己可以设置一个NSArray之类的集合来管理你的数据的生命周期)&lt;/li&gt;
&lt;li&gt;使用上面讲过的refreshObject:mergeChanges也可以用来打破object之间的retain cycle&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;4-2-object-life-cycle&#34;&gt;4.2  Object Life-Cycle&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;init:three different ways you can customize initialization —by overriding initWithEntity: insertIntoManagedObjectContext:, awakeFromInsert, or awakeFromFetch 不要override init ;推荐使用awakeFromInsert, or awakeFromFetch分别在insetNew和fetch方法之后被执行&lt;/li&gt;
&lt;li&gt;validate:not override validateValue:forKey:error: ; override validate&lt;Key&gt;:error:. If you want to validate inter-property values, you can override validateForUpdate: and/or related validation methods; validateValue:forKey:error: 内部会自动调用 validate&lt;Key&gt;:error:&lt;/li&gt;
&lt;li&gt;delloc:不要重载delloc;core data负责释放资源,释放之前调用didTurnIntoFault;可以重载didTurnIntoFault&lt;/li&gt;
&lt;li&gt;fault:an object whose property values have not yet been loaded from the external data store
1.你的datasource何时被释放
2.context的cache何时释放&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;4-3-faulting-and-uniquing&#34;&gt;4.3  Faulting and Uniquing&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;A fault is a placeholder object that represents 1)&lt;code&gt;a managed object that has not yet been fully realized&lt;/code&gt;, or 2)&lt;code&gt;a collection object that represents a relationship&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;fault的使用相当于lazy loading除非使用否则不需要真正的fetch,这样就减少了内存使用.fetch的动作叫做fire the fault.如果是fault那么可能是下面说的情况2)在缓存中，3)不在缓存中,需要fetch 可以用isFault测试,如果是NO那么肯定是情况1)

&lt;ul&gt;
&lt;li&gt;1)对象已经在 context 中，这种操作基本上是没有任何代价的。&lt;/li&gt;
&lt;li&gt;2)对象不在 context 中，但是因为你最近从 store 中取出过对象，所以持久化存储协调器缓存了对象的值。这个操作还算廉价（但是，一些操作会被锁住）。操作耗费最昂贵的情况是&lt;/li&gt;
&lt;li&gt;3)当 context 和持久化存储协调器都是第一次访问这个对象，这种情况必须通过 store 从 SQLite 数据库取回。&lt;/li&gt;
&lt;li&gt;注意区别fault和cache的区别,变成fault还是占内存的,只是变成一个类似指针的占位符,然后fault
之后可能会释放所有对它的reference,这时会将其清除出cache,不占任何内存;(分别用refeash和reset强制控制)。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;refreshObject:mergeChanges:可以手动把一个object变成fault=&amp;gt;会发出 didTurnIntoFault 的message;可以重载做&amp;rdquo;housekeeping&amp;rdquo;类的一些操作; key-value observing (KVO) change notifications也会被sent&lt;/li&gt;
&lt;li&gt;Uniquing是保证an entry in a persistent store is associated with only one managed object的技术&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;a-name-relationshipandfetchproperties-7-a-5-relationship-and-fetch-properties&#34;&gt;&lt;a name=&#39;RelationshipAndfetchproperties-7&#39;&gt;&lt;/a&gt;5.Relationship And fetch properties&lt;/h2&gt;

&lt;h5 id=&#34;5-1-relationship定义&#34;&gt;5.1 Relationship定义&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Relationship可以同时是optional的又设置上下限,意思是可以不存在,但是如果存在那么就要满足上下限要求&lt;/li&gt;
&lt;li&gt;Relationship Delete Rules:Deny;Nullify;Cascade;No Action几种rule觉得delete对象时的操作(很好理解详见programming guide -p84)。当你移动,删除一个带有关系的object的时候,coredata 会自动为你检查规则和更新关系.&lt;/li&gt;
&lt;li&gt;programming guide -p84有一个many to many的例子,大多时候数据库效率不高或者难于使用并不是framework的问题,而是设计不合理。&lt;/li&gt;
&lt;li&gt;Relationship一般都是双向的,创建一个单向的relationship基本没什么好处.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;5-2-fetched-properties&#34;&gt;5.2 Fetched Properties&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Fetched properties represent weak, one-way relationships但是不同的是fetch语句实现的,因此是array，evaluated lazily;&lt;/li&gt;
&lt;li&gt;Fetched properties和fetch request template都是fetch语句,不同的是Fetched properties会cache fetch的object（这里要注意keep data up-to-date）;同时Fetched properties一般用在fetch 不同的table之间的元素;fetch request template;fetch的是一个table里的元素 两者都可以在代码里通过一个fetch语句实现&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;5-3-例子-获得一组数据中创建日期最早的那个的日期&#34;&gt;5.3 例子 获得一组数据中创建日期最早的那个的日期&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;方法1:fetch所有的排序,取第一个;===&amp;gt;设置fetch limit只取一个&lt;/li&gt;
&lt;li&gt;方法2:fetch所有的排序,取第一个;和1不同的是只fetch日期这个字段&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;[fetchRequest setResultType:NSDictionaryResultType]; 
[fetchRequest setPropertiesToFetch:[NSArray arrayWithObject:@&amp;quot;createdAt&amp;quot;]];
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方法3:使用Expression效率最高NSExpression＝＝》NSExpressionDescription＝》setPropertiesToFetch&lt;/p&gt;

&lt;h2 id=&#34;a-name-usingpersistentstores-8-a-6-using-persistent-stores&#34;&gt;&lt;a name=&#39;UsingPersistentStores-8&#39;&gt;&lt;/a&gt;6. Using Persistent Stores&lt;/h2&gt;

&lt;h5 id=&#34;6-1-创建一个store-nspersistentstore&#34;&gt;6.1 创建一个store:NSPersistentStore&lt;/h5&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//使用这个函数会创建一个NSPersistentStore代表了你的存储文件,一个隐含的操作是,如果存储文件不存在,就会先创建它
NSPersistentStoreCoordinator *psc = [moc persistentStoreCoordinator];
NSPersistentStore *roStore = [psc addPersistentStoreWithType:NSXMLStoreType
                                configuration:nil URL:url options:options error:&amp;amp;error];

//你不会直接使用NSPersistentStore;而是应该通过NSPersistentStoreCoordinator
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;6-2-changing-a-store-s-type-and-location&#34;&gt;6.2 Changing a Store’s Type and Location&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;NSPersistentStoreCoordinator *psc = [aManagedObjectContext
persistentStoreCoordinator];
NSURL *oldURL = &amp;lt;#URL identifying the location of the current store#&amp;gt;;
NSURL *newURL = &amp;lt;#URL identifying the location of the new store#&amp;gt;;
NSError *error = nil;
NSPersistentStore *xmlStore = [psc persistentStoreForURL:oldURL];
NSPersistentStore *sqLiteStore = [psc migratePersistentStore:xmlStore
									   toURL:newURL options:nil withType:NSSQLiteStoreType error:&amp;amp;error];									   									   
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;6-3-associate-metadata-with-a-store&#34;&gt;6.3 Associate Metadata With a Store&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;get： metadataForPersistentStore:/ metadataForPersistentStoreOfType:URL:error:.&lt;/li&gt;
&lt;li&gt;set: setMetadata:forPersistentStore:/setMetadata:forPersistentStoreOfType:URL:error:.&lt;/li&gt;
&lt;li&gt;use: 一个使用场景是migration=&amp;gt;使用系统自动创建的metadata就可以了isConfiguration:compatibleWithStoreMetadata;metadata不同(如版本)就会返回NO&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-name-howtopreloadandimportexistingdata-9-a-7-how-to-preload-and-import-existing-data&#34;&gt;&lt;a name=&#39;HowToPreloadandImportExistingData-9&#39;&gt;&lt;/a&gt;7.How To Preload and Import Existing Data&lt;/h2&gt;

&lt;p&gt;两种解决方案&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Fill in Core Data on startup from external source&lt;/code&gt;. For this the app can start up, notice that the database hasn’t been imported yet, and start reading in data from an external source (such as an SQLite database or XML file) and then start inserting the data into Core Data.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Provide pre-filled in SQLite database&lt;/code&gt;. For this we’ll let Core Data create the database structure for us based on the model, and then we populate the database with a utility app. The utility app could be a Mac or iPhone app that uses Core Data to populate the database via Core Data APIs, or some kind of program that fills in the SQLite database directly. Once the database is populated, just include it with the app and make the app use it as the default database if no database already exists. 就是代码里先生成sqlite文件,加入bundle,初始化的时候 copyItemAtURL 复制到本地目录.这是苹果文档官方推荐的方法,但是考虑到先创建数据库文件可能使得文件比较大,这个需要权衡.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;a-name-fetchedresultscontrolleruitableview-10-a-8-fetched-results-controller-uitableview&#34;&gt;&lt;a name=&#39;FetchedResultsControllerUITableView-10&#39;&gt;&lt;/a&gt;8.Fetched Results Controller&amp;lt;=&amp;gt;UITableView&lt;/h2&gt;

&lt;h5 id=&#34;8-1-简介&#34;&gt;8.1 简介&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;ee&lt;/li&gt;
&lt;li&gt;组成

&lt;ul&gt;
&lt;li&gt;A fetch request (NSFetchRequest instance):The one difference in this fetch request is that it must have at least one sort descriptor&lt;/li&gt;
&lt;li&gt;A managed object context&lt;/li&gt;
&lt;li&gt;A section name key path:用于coredata自动根据keypathname分割成几个section&lt;/li&gt;
&lt;li&gt;A cache name&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;a-name-class-3-a-三-深入-走上人生巅峰&#34;&gt;&lt;a name=&#39;class-3&#39;&gt;&lt;/a&gt;三.深入（走上人生巅峰）&lt;/h1&gt;

&lt;h2 id=&#34;a-name-migrations-11-a-1-migrations&#34;&gt;&lt;a name=&#39;Migrations-11&#39;&gt;&lt;/a&gt;1.Migrations&lt;/h2&gt;

&lt;h5 id=&#34;1-1-lightweight-migrations&#34;&gt;1.1 Lightweight Migrations&lt;/h5&gt;

&lt;p&gt;一类比较小的迁移,不需要创建mapping model;coredata会自动使用sql语句进行迁移，不需要load data或者转移整个store所以效率一般很高.(迁移之后iOS 5 keeps only the post-migration version)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//1.1
NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys:
				[NSNumber numberWithBool:YES], NSMigratePersistentStoresAutomaticallyOption, //tells the persistent store coordinator to automatically migrate the data.
				[NSNumber numberWithBool:YES], NSInferMappingModelAutomaticallyOption, nil];//tells the persistent store coordinator to infer 推断 the mapping model.
				
//对于1,2 设置 NSInferMappingModelAutomaticallyOption为NO!!!

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;


    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/200012.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    





    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/200013.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    





    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/200014.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    

&lt;/p&gt;

&lt;h5 id=&#34;1-2-migrate-with-mapping-model&#34;&gt;1.2 Migrate With Mapping Model&lt;/h5&gt;

&lt;p&gt;当改变不限于1.1所述的轻度迁移的时候，需要创建mappging model-》tell Core Data how to execute the migration&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NSAddEntityMappingType;NSRemoveEntityMappingType;NSCopyEntityMappingType lightweight migrations就可以处理&lt;/li&gt;
&lt;li&gt;NSTransformEntityMappingType可以用 value expression 来描述&lt;/li&gt;
&lt;li&gt;NSCustomEntityMappingType 则需要创建一个 NSEntityMigrationPolicy 的子类来描述;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;处理步骤



    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/200015.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    

&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//Core Data runs your migration in three stages.这个步骤细节可以由NSEntityMigrationPolicy来描述
1. It creates the objects in the destination model, including their attributes, based on the objects in the source model. ==&amp;gt;createDestinationInstancesForSourceInstance
2. It creates the relationships among the objects in the destination model.=&amp;gt;createRelationshipsForDestinationInstance
3. It validates the data in the destination model and saves it.=&amp;gt;performCustomValidationForEntityMapping

//2 example use expression: FUNCTION($manager, &amp;quot;destinationInstancesForEntityMappingNamed:sourceInstances:&amp;quot; , &amp;quot;CanvasToCanvas&amp;quot;, $source.canvases)
//caveat:createDestinationInstancesForSourceInstance的时候如果不super那么需要associateSourceInstance: withDestinationInstance: forEntityMapping: 
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;1-3-渐进式迁移-progressive-migrations-http-objccn-io-issue-4-7&#34;&gt;1.3 渐进式迁移 (Progressive Migrations)&lt;a href=&#34;http://objccn.io/issue-4-7/&#34;&gt;http://objccn.io/issue-4-7/&lt;/a&gt;&lt;/h5&gt;

&lt;h2 id=&#34;a-name-multiplecontext-12-a-2-multiple-context&#34;&gt;&lt;a name=&#39;Multiplecontext-12&#39;&gt;&lt;/a&gt;2. Multiple context&lt;/h2&gt;

&lt;h5 id=&#34;2-1-如何处理冲突&#34;&gt;2.1 如何处理冲突&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;Conflict Detection and Optimistic Locking:Optimistic Locking的原理When Core Data fetches an object from a persistent store, it takes a snapshot of its state,保存的时候要比较这个数据库里的对象和它的snapshot,如果不同说明这个对象在fetch之后被别人改过了=&amp;gt;Optimistic Locking(snapshot也会占用内存,它通过叫snapshot reference counting的机制管理)&lt;/li&gt;
&lt;li&gt;如何处理冲突由NSErrorMergePolicy(默认)/NSMergeByPropertyStoreTrumpMergePolicy/NSMergeByPropertyObjectTrumpMergePolicy/NSOverwriteMergePolicy指定&lt;/li&gt;
&lt;li&gt;Communicating Changes Between Contexts: NSManagedObjectContextDidSave&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;a-name-concurrencywithcoredata-13-a-3-concurrency-with-core-data&#34;&gt;&lt;a name=&#39;ConcurrencywithCoreData-13&#39;&gt;&lt;/a&gt;3. Concurrency with Core Data&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;For the most part, AppKit and UIKit are not thread safe; in particular, on OS X Cocoa bindings and controllers are not thread safe—if you are using these technologies, multi-threading may be complex.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;3-1-typically-recommended-approach&#34;&gt;3.1 typically-recommended approach&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Create a separate managed object context for each thread and share a single persistent store coordinator.不应该在不同thread传递Managed Object;如果要访问同一个entity,可以使用objectID或者构建同样的fetch;&lt;/li&gt;
&lt;li&gt;一般没有必要给Managed Object或者contexts lock(programming guide p137描述了需要lock the persistent store coordinator的情况)&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;3-2-track-changes-in-other-threads-using-notifications&#34;&gt;3.2 Track Changes in Other Threads Using Notifications&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;没错,Notifications..需要注意的是哪个线程post的Notifications那个线程才能收到,因此你需要在你save的contex所在的线程使用,比如使用performselector [mergeChangesFromContextDidSaveNotification] on Thread(你想通知的context所在的线程)&lt;/li&gt;
&lt;li&gt;你希望收到通知的线程注册NSManagedObjectContextDidSaveNotification;(再把他作为参数发给mergeChangesFromContextDidSaveNotification.这样 the context is able to safely merge the changes.);由于不同object和不同context关联,所以不改直接传递。可以传递objectid&lt;/li&gt;
&lt;li&gt;Fetch in the Background for UI Responsiveness;&lt;code&gt;fetch操作是经过内部优化的,如果需要coredata会自己新建线程来加快操作&lt;/code&gt;.但是如果还是需要在子线程fetch来防止UI阻塞,你可以新建background thread 以及对应的context,在其中fetch然后传递object ID;另一个线程通过object ID获取已经cache了object&lt;/li&gt;
&lt;li&gt;在后台线程保存:If you need to save on a background thread, you must write additional code such that the main thread prevents the application from quitting until all the save operation is complete.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;注意点
1.Use one NSPersistentStoreCoordinator per program. You don&#39;t need them per thread.
2.Create one NSManagedObjectContext per thread.
3.Never pass an NSManagedObject on a thread to the other thread.
4.Instead, get the object IDs via -objectID and pass it to the other thread.
More rules:

5.Make sure you save the object into the store before getting the object ID. Until saved, they&#39;re temporary, .and you can&#39;t access them from another thread.
6.And beware of the merge policies if you make changes to the managed objects from more than one thread.
7.NSManagedObjectContext&#39;s -mergeChangesFromContextDidSaveNotification: is helpful.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-coredataperformance-14-a-4-core-data-performance-提高效率的一些提示&#34;&gt;&lt;a name=&#39;CoreDataPerformance-14&#39;&gt;&lt;/a&gt;4.Core Data Performance 提高效率的一些提示&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Predicates的使用有技巧:一个例子 (salary &amp;gt; 5000000) AND (lastName LIKE &amp;lsquo;Quincey&amp;rsquo;) 比 (lastName LIKE &amp;lsquo;Quincey&amp;rsquo;) AND (salary &amp;gt; 5000000) 好；&lt;code&gt;巧用subquery能极大的提高fetch效率&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;fetchLimit:如果数据很多需要设置它,一次拉一部分数据;fetch某个需要的属性其他不要。&lt;/li&gt;
&lt;li&gt;不要fire 一个 fault的时候,不要fire&lt;/li&gt;
&lt;li&gt;Batch Faulting and Pre-fetching with the SQLite Store:有些情况下一个个的fire fault反而效率很低,这时候可以&lt;code&gt;batch fault&lt;/code&gt;（fetch request using a predicate with an IN operator或者use the NSFetchRequest method setReturnsObjectsAsFaults）&lt;code&gt;Pre-fetching&lt;/code&gt;（use the NSFetchRequest method setRelationshipKeyPathsForPrefetching）【p145】&lt;/li&gt;

&lt;li&gt;&lt;p&gt;节约内存&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;re-fault an individual managed object using NSManagedObjectContext’s refreshObject:mergeChanges: method&lt;/li&gt;
&lt;li&gt;create a fetch request you can set includesPropertyValues to NO 当你确定不需要使用这个property的时候&lt;/li&gt;
&lt;li&gt;reset method of NSManagedObjectContext to remove all managed objects associated with a context&lt;/li&gt;
&lt;li&gt;If you iterate over a lot of objects, you may need to use local autorelease pool block&lt;/li&gt;
&lt;li&gt;If you do not intend to use Core Data’s undo functionality, you can reduce your application&amp;rsquo;s resource requirements by setting the context’s undo manager to nil.&lt;/li&gt;
&lt;li&gt;break cycles by re-faulting objects (again by using the refreshObject:mergeChanges&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;使用instrument中的coredata工具&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;//不会fire fault的方法
isEqual:, hash, superclass, class, self, zone, isProxy, isKindOfClass:, isMemberOfClass:, conformsToProtocol:, respondsToSelector:, description, managedObjectContext, entity, objectID, isInserted, isUpdated, isDeleted, and isFault.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-multiplepersistentstorecustompersistentstore-15-a-5-multiple-persistent-store-custom-persistent-store&#34;&gt;&lt;a name=&#39;MultiplePersistentStoreCustomPersistentStore-15&#39;&gt;&lt;/a&gt;5.Multiple Persistent Store &amp;amp; Custom Persistent Store&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Multiple Persistent Store可以使用configuration进行配置,这样可以split data 到不同的data store;[persistentStoreCoordinator_ addPersistentStoreWithType:NSSQLiteStoreType configuration:@&amp;ldquo;Passwords&amp;rdquo; URL:passwordStoreURL options:nil error:&amp;amp;error]&lt;/li&gt;
&lt;li&gt;coredata允许创建custom的存储方式,但是这种方式只能是atomic store types（An atomic store is a store that writes its entire content all at once every time a save operation is executed）.比如可以创建类似CSV file的保存格式.&lt;/li&gt;
&lt;li&gt;需继承NSAtomicStore:在NSAtomicStore重载load和save等方法.比方说对于一个CSV文件,就是对文本的解析和保存,类似json的解析和序列化.而使用NSAtomicStore的好处是底层保存格式发生改变的时候上层代码不需要改变.&lt;/li&gt;
&lt;/ul&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/200016.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;h2 id=&#34;a-name-nspredicatensexpression-16-a-6-补充nspredicate和nsexpression入门&#34;&gt;&lt;a name=&#39;NSPredicateNSExpression-16&#39;&gt;&lt;/a&gt;6.补充NSPredicate和NSExpression入门&lt;/h2&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/200017.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;h5 id=&#34;6-1-nsexpression是nspredicate的内部实现方式&#34;&gt;6.1 NSExpression是NSPredicate的内部实现方式&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;NSPredicate是非常有用的，是Cocoa的优势之一。&lt;/code&gt;在&lt;code&gt;处理数据&lt;/code&gt;的时候要善于使用NSPredicate可以使代码清楚简介。(比如当你在filter一个array的时候不要再使用遍历了)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//用NSExpression实现
NSExpression *exprName = [NSExpression expressionForKeyPath:@&amp;quot;name&amp;quot;];
 NSExpression *exprJ = [NSExpression expressionForConstantValue:@&amp;quot;J&amp;quot;];
NSPredicate *p1 = [NSComparisonPredicate predicateWithLeftExpression:exprName rightExpression:exprJ modifier:NSDirectPredicateModifier type:NSBeginsWithPredicateOperatorType options:0];
NSExpression *exprAge = [NSExpression expressionForKeyPath:@&amp;quot;age&amp;quot;];
NSExpression *lower = [NSExpression expressionForConstantValue:[NSNumber numberWithInt:20]];
NSExpression *upper = [NSExpression expressionForConstantValue:[NSNumber numberWithInt:35]];
NSExpression *exprRange = [NSExpression expressionForAggregate:[NSArray arrayWithObjects:lower, upper, nil]];
NSPredicate *p2 = [NSComparisonPredicate predicateWithLeftExpression:exprAge rightExpression:exprRange modifier:NSDirectPredicateModifier type:NSBetweenPredicateOperatorType options:0];
NSPredicate *predicate = [NSCompoundPredicate andPredicateWithSubpredicates:[NSArray arrayWithObjects:p1, p2, nil]];

//改写成NSPredicate+query language
NSPredicate *predicate = [NSPredicate predicateWithFormat:@&amp;quot;name BEGINSWITH %@ AND age BETWEEN {%d, %d}&amp;quot;, @&amp;quot;J&amp;quot;, 20, 35];
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;6-2-nspredicate相关&#34;&gt;6.2 NSPredicate相关&lt;/h5&gt;

&lt;p&gt;


    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/200018.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    





    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/200019.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    





    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/200020.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    





    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/200021.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    





    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/200022.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    





    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/200023.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    





    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;https://u2takey.github.io/img/2015/02/200024.png&#34; alt=&#34;Alt Text&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    

&lt;/p&gt;

&lt;h4 id=&#34;a-name-17-a-参考&#34;&gt;&lt;a name=&#39;-17&#39;&gt;&lt;/a&gt;参考&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;注意:部分资料比较陈旧,请查看最新版&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/mapleyuan/p/3355615.html&#34;&gt;coredata 学习指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CoreData/cdProgrammingGuide.html&#34;&gt;Core Data Tutorial for iOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/samplecode/CoreDataUtility/Introduction/Intro.html&#34;&gt;Core Data Utility Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CoreData/cdProgrammingGuide.html&#34;&gt;Core Data Programming Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Predicates/predicates.html&#34;&gt;Predicate Programming Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/DataManagement/Conceptual/CoreDataSnippets/Introduction/Introduction.html&#34;&gt;Core Data Snippets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreDataVersioning/Articles/Introduction.html&#34;&gt;Core Data Model Versioning and Data Migration Programming Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/AtomicStore_Concepts/Introduction/Introduction.html&#34;&gt;Atomic Store Programming Topics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/Library/ios/documentation/DataManagement/Conceptual/IncrementalStorePG/Introduction/Introduction.html&#34;&gt;Incremental Store Programming Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.informit.com/articles/article.aspx?p=2160906&#34;&gt;Avoiding Ten Big Mistakes iOS Developers Make with Core Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/kesalin/article/details/6739319&#34;&gt;深入浅出 Cocoa 之 Core Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://objccn.io/&#34;&gt;objccn.io有8篇翻译的coredata介绍的文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://useyourloaf.com/blog/2012/01/19/core-data-queries-using-expressions.html&#34;&gt;Core Data Queries Using Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.raywenderlich.com/14742/core-data-on-ios-5-tutorial-how-to-work-with-relations-and-predicates&#34;&gt;How To Work with Relations and Predicates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.nsguy.com/blog/2014/02/09/learning-core-data/&#34;&gt;CoreData并发处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Pro Core Data for iOS【Data Access and Persistence Engine for iPhone, iPad, and iPod touch
Second Edition】&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nshipster.cn/nspredicate/&#34;&gt;NSPredicate&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;a-name-18-a-资源&#34;&gt;&lt;a name=&#39;-18&#39;&gt;&lt;/a&gt;资源&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://sourceforge.net/projects/sqlitebrowser/files/latest/download&#34;&gt;sqlitebrowser&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;a-name-19-a-更新&#34;&gt;&lt;a name=&#39;-19&#39;&gt;&lt;/a&gt;更新&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;2014-8-3第一版&lt;/li&gt;
&lt;li&gt;2014-8-11增加了来自Pro Core Data for iOS的内容&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>